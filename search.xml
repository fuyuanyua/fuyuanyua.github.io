<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入理解HashMap]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap%2F</url>
    <content type="text"><![CDATA[HashMap的默认初始容量为16。 1. HashMap的数据结构Java中HashMap的数据结构： JDK1.7：数组+链表的组合。 JDK1.8：数组+链表（或者红黑树）的组合。 2. HashMap的属性2.1 重要的常量通过源码查看HashMap的一些重要常量： 123456789101112131415161718192021222324252627282930/** * 默认初始容量为1向左移位4位，即00000001变成00010000，也就是1乘以2的4次方 * 即默认初始容量（桶的数量，也就是Node&lt;K,V&gt;[] table数组的长度）为16 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * 最大容量（桶的数量）为1向左移位30位，也就是1乘以2的30次方 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认加载因子为0.75 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * 链表转换为红黑树的阈值 */static final int TREEIFY_THRESHOLD = 8;/** * 红黑树转换为链表的阈值 */static final int UNTREEIFY_THRESHOLD = 6;/** * 由链表转换为红黑树的最小容量（桶的数量）阈值 */static final int MIN_TREEIFY_CAPACITY = 64; 2.2 重要的变量通过源码查看HashMap的一些重要变量： 12345678910111213141516171819202122232425/** * 储存桶的数组 */transient Node&lt;K,V&gt;[] table;/** * HashMap中存储的键值对的数量 */transient int size;/** * HashMap结构修改的次数 */transient int modCount;/** * threshold = capacity * load factor * 扩容阈值，当size &gt;= threshold，就会扩容 */int threshold;/** * 加载因子 */final float loadFactor; 2.3 认识Node&lt;K,V&gt;在2.2有一段源码transient Node&lt;K,V&gt;[] table;，可知table是存储Node&lt;K,V&gt;的数组，可Node&lt;K,V&gt;是什么呢？ 查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // hash(key.hashCode())方法的返回值 final int hash; // 键 final K key; // 值 V value; // 下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; Node翻译为节点，Node&lt;K,V&gt;是HashMap的一个内部类，实现了Map.Entry&lt;K,V&gt;接口，本质上就是一个键值对。 3. HashMap的构造方法HashMap部分源码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; /** * 构造方法一 */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * 构造方法二 */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * 构造方法三 */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * 构造方法四 */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125;&#125; 3.1 HashMap的四个构造方法 public HashMap(int initialCapacity, float loadFactor)：构造一个指定初始容量和加载因子的空HashMap。 public HashMap(int initialCapacity)：构造一个指定初始容量和默认加载因子（0.75）的空HashMap。 public HashMap()：构造一个默认初始容量（16）和默认加载因子（0.75）的空HashMap。 public HashMap(Map&lt;? extends K, ? extends V&gt; m)：用现有的一个Map来构造一个HashMap。 以上提到了两个参数：initialCapacity（初始容量）和loadFactor（加载因子）。 初始容量表示HashMap中桶的数量，也就是源码中table数组的长度，默认初始容量为16。 加载因子是衡量一个散列表的空间使用程度。如果加载因子变大（加载因子可以大于1），表示空间利用率变大，但同时键与键碰撞率加大，链表长度变长，增删改查操作效率降低；加载因子变小，空间利用率降低，但同时键与键的碰撞率变小，链表长度变低，增删改查效率提高。默认值为0.75，是JDK开发者经过充分计算得出的最优值，我们一般不去修改。 3.2 容量重计算当然，我们设置一个初始容量，HashMap并不一定直接采用我们设置的值，通过分析源码可以知道： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 如果我们设置的初始容量是2的幂，则HashMap直接采用我们设置的值。 若不是，HashMap会采用大于该值的第一个2的幂（比如我们设置3，则是4；设置7，则是8）。 注意： 通过以上方法得到的capacity却在构造方法中被初始化赋值给了thresholdthis.threshold = tableSizeFor(initialCapacity);，我百思不得其解，觉得应该是this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;才对，但其实在构造方法中并没有对table数组初始化，table的初始化被推迟到了put方法中，put方法会重新对threshold进行计算。 JDK底层源码很多都采用了移位运算，大大提高效率。 3.3 推荐使用的构造方法《阿里巴巴Java开发手册》推荐： 4. put方法HashMap的put方法源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 初始化桶数组table，table被延迟到了put时才初始化，而不是在构造方法时初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 根据桶数组length - 1和hash进行与运算得到对应的数组下标 // 数组中这个下标为空时，新建对应Node放入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 数组中这个下标不为空 else &#123; Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; // HashMap的结构修改次数加1 ++modCount; // 判断是否要扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 4.1 逻辑分析put方法入口在public V put(K key, V value)，但真正的逻辑写在final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)方法中，我们具体分析putVal方法： 4.1.112if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; 首先判断桶数组table是否为空，如果为空，调用resize()方法进行扩容，扩容的结果就是初始化一个长度为16的桶数组table。然后将table的长度赋值给n。 注意： 桶数组table不在构造方法中初始化，而是在put中通过resize()初始化，主要是为了防止初始化HashMap后没有数据插入造成空间浪费的情况。resize()方法会稍后深入探讨。 4.1.212if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); 1234// Create a regular (non-tree) node Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; return new Node&lt;&gt;(hash, key, value, next); &#125; 根据桶数组table的长度 - 1和hash值进行与（&amp;）位运算，算出hash值对应于桶数组table中的位置（下标），如果数组当前位置为空，则在这个位置新增一个对应的Node。 注意： hash值其实不是key的原始hashCode，是经过hash(Object)方法获得的再次计算的hash值。hash(Object)方法会稍后深入探讨。 n - 1和hash值进行与（&amp;）运算，等同于hash对length进行取模运算，即hash % n，但用与运算大大提高效率，因为是直接进行二进制运算。 newNode(hash, key, value, null);是一个方法，返回新建的Node。 4.2 resize()方法源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 4.3 hash(Object)方法源码： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 如果key为空，则hash值为0（这也是为什么HashMap的key可以为null的原因）。 如果key不为空，则hash值为：将key的hashCode与key的hashCode无符号右移16位得到的结果进行异或运算得到的结果。（自定义类作为HashMap的key要重写hashCode()方法： https://fuyuanyua.github.io/2019/05/14/Java%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84%E9%94%AE/ ） 使用hash(Object)方法进行二次hash计算，而不直接采用.hashCode()，主要是为了让键值对更均匀的分布在各个桶中，减少键与键的碰撞，降低链表长度，提高增删改查性能。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述分派]]></title>
    <url>%2F2019%2F05%2F23%2F%E7%AE%80%E8%BF%B0%E5%88%86%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[1. 分派分派指的是在Java中对方法的调用，分派可分为： 静态分派 动态分派 2. 静态分派先区分静态类型和实际类型：假设Animal为父类，Dog为子类，Animal animal = new Dog(); 则对象animal的静态类型为Animal，在编译时便确定。 实际类型为Dog，在运行时才确定。 根据对象的静态类型来确定执行哪个方法版本，叫做静态分派，典型应用为方法重载。 发生在编译阶段，静态分派的动作不是JVM来执行的。 3. 动态分派根据对象的实际类型来确定执行哪个方法版本，叫做动态分派，典型应用为方法重写。 发生在运行时期，动态分派由JVM来执行。 动态分派的实现是在方法区建立方法表： 如果子类没有重写父类该方法，则子类虚方法表中该方法指向父类该方法的入口地址。 如果子类重写了父类该方法，则子类虚方法中该方法指向子类重写后的该方法入口地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务的隔离级别]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[详见本博文： https://fuyuanyua.github.io/2019/04/09/Spring-Boot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程start方法和run方法的区别]]></title>
    <url>%2F2019%2F05%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8Bstart%E6%96%B9%E6%B3%95%E5%92%8Crun%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[start()方法： 是Thread类中的一个方法。 启动主线程以外的线程，唯一方法就是调用start()方法，真正实现多线程。 调用start()方法后，start()方法调用Thread类（也就是自身类）的native方法start0()，这时此线程就处于Runnable状态，一旦得到系统的调度，就执行run()方法，run()方法代码执行完，此线程便终止。 run()方法： 最初是在Runable接口被定义的抽象方法。 无论是在Thread类中被重写，还是在继承了Thread类的子类中被重写，run()方法都只是一个普通的方法。 如果直接调用run()方法，依然在主线程中按顺序执行，无法实现多线程。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现多线程]]></title>
    <url>%2F2019%2F05%2F20%2FJava%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. Java实现多线程四种方式 继承Thread类。 实现Runable接口。 实现Callable接口。 线程池。 2. 继承Thread类2.1 简介Thread类来自java.lang.Thread。 Thread类的继承关系： Thread类实现了Runable接口和Runable接口的run()方法。 2.2 示例以下创建MyThread类继承Thread类，并重写run()方法： 1234567891011121314151617181920212223242526272829/** * @ClassName: MyThread * @Description: 继承Thread类实现多线程 * @Author: LiHaibin * @Date: 2019-05-19 18:37 * @Version: V1.0 **/public class MyThread extends Thread &#123; private String name; public MyThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行" + i + "次"); try &#123; /*sleep(3 * 1000);*/ sleep((long) (Math.random() * 10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试代码： 1234567891011121314151617/** * @ClassName: Test * @Description: 测试继承Thread类，实现多线程 * @Author: LiHaibin * @Date: 2019-05-20 15:10 * @Version: V1.0 **/public class Test &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread("a"); MyThread myThread1 = new MyThread("b"); myThread.start(); myThread1.start(); &#125;&#125; 在启动的多线程的时候，需要先通过Thread类的继承类MyThread类的构造方法构造出对象，然后调用MyThread对象的start()方法来运行多线程代码。 2.3 测试效果控制台打印输出： 第一次运行： 123456789101112b运行0次a运行0次b运行1次a运行1次a运行2次b运行2次a运行3次a运行4次b运行3次b运行4次Process finished with exit code 0 第二次运行： 123456789101112a运行0次b运行0次a运行1次b运行1次b运行2次a运行2次a运行3次b运行3次a运行4次b运行4次Process finished with exit code 0 发现两次运行，多线程的代码执行顺序不一样。 3. 实现Runable接口3.1 简介Runable接口来自java.lang.Runnable。 Runable接口仅定义了一个run()抽象方法。 123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 3.2 示例以下创建MyThread1实现Runnable接口，重写Runnable接口的run()抽象方法： 12345678910111213141516171819202122232425262728/** * @ClassName: MyThread1 * @Description: 调用Runable接口实现多线程 * @Author: LiHaibin * @Date: 2019-05-20 15:45 * @Version: V1.0 **/public class MyThread1 implements Runnable &#123; private String name; public MyThread1(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行" + i + "次"); try &#123; Thread.sleep((long) (Math.random() * 10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试代码： 123456789101112131415/** * @ClassName: Test1 * @Description: 测试实现Runable接口，实现多线程 * @Author: LiHaibin * @Date: 2019-05-20 16:26 * @Version: V1.0 **/public class Test1 &#123; public static void main(String[] args) &#123; // 新建MyThread1类对象当做Thread对象的target new Thread(new MyThread1("c")).start(); new Thread(new MyThread1("d")).start(); &#125;&#125; 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 Thread类构造方法： 123456789101112131415/** * Allocates a new &#123;@code Thread&#125; object. This constructor has the same * effect as &#123;@linkplain #Thread(ThreadGroup,Runnable,String) Thread&#125; * &#123;@code (null, target, gname)&#125;, where &#123;@code gname&#125; is a newly generated * name. Automatically generated names are of the form * &#123;@code "Thread-"+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer. * * @param target * the object whose &#123;@code run&#125; method is invoked when this thread * is started. If &#123;@code null&#125;, this classes &#123;@code run&#125; method does * nothing. */public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125; 把Runnable接口的实现类MyThread1的对象向上转型变成Runnable接口的对象target。如果不懂，可以思考一下List&lt;String&gt; list = new ArrayList&lt;&gt;();，List是接口，ArrayList是List接口的实现类，是面向接口编程思想：https://blog.csdn.net/jingshaozhi/article/details/80006464 3.3 测试效果控制台打印输出： 第一次运行： 123456789101112c运行0次d运行0次d运行1次c运行1次c运行2次d运行2次d运行3次c运行3次d运行4次c运行4次Process finished with exit code 0 第二次运行： 123456789101112c运行0次d运行0次d运行1次d运行2次c运行1次c运行2次d运行3次d运行4次c运行3次c运行4次Process finished with exit code 0 发现两次运行，多线程的代码执行顺序依然不一样。 所以：多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。 4. 小结 无论以何种方式实现多线程，启动线程以外的线程，唯一方法就是通过Thread类对象的start()方法。 查看Thread类源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /** * Causes this thread to begin execution; the Java Virtual Machine * calls the &lt;code&gt;run&lt;/code&gt; method of this thread. * &lt;p&gt; * The result is that two threads are running concurrently: the * current thread (which returns from the call to the * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its * &lt;code&gt;run&lt;/code&gt; method). * &lt;p&gt; * It is never legal to start a thread more than once. * In particular, a thread may not be restarted once it has completed * execution. * * @exception IllegalThreadStateException if the thread was already * started. * @see #run() * @see #stop() */ public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; private native void start0(); /** * If this thread was constructed using a separate * &lt;code&gt;Runnable&lt;/code&gt; run object, then that * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called; * otherwise, this method does nothing and returns. * &lt;p&gt; * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method. * * @see #start() * @see #stop() * @see #Thread(ThreadGroup, Runnable, String) */ @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 分析以上源码可以知道，start()方法调用了native方法start0()（使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，由Java去调用），它将启动一个新的线程，并执行run()方法： 如果是以继承Thread类的方式，执行Thread类的子类重写的run()方法。 如果是以实现Runable接口的方式，执行实现类重写的run()方法。 start()方法的调用后并不是立即执行多线程run()代码，而是使得该线程变为可运行状态（Runnable），什么时候执行是由操作系统调度决定的。 run()方法是多线程的一个接口约定，所有的多线程代码都写在run()方法里面。 多线程代码执行顺序是不确定的。 运行程序main()方法时，JVM便启动一个Java进程，main()是主线程，然后随着调用对象的start()方法，另外的线程也启动了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中线程的生命周期]]></title>
    <url>%2F2019%2F05%2F19%2FJava%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1. 进程与线程1.1 进程（Process）对于Windows、Mac OS X等操作系统，比如打开一个浏览器就是启动一个浏览器进程，打开一个Word文档就是启动一个Word进程。 进程是系统进行资源分配和调度的一个独立单位，进程是资源分配的最小单位。 多个进程可以在单个处理器上并发执行，互不影响。 一个进程可以有多个线程。 1.2 线程（Thread）有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程。 线程是cpu调度的最小单位。 线程不拥有系统资源。 一个进程可以有多个线程，多个线程共享该进程内存和资源（共享的内存是堆内存和方法区内存，栈内存不共享，每个线程有自己的栈内存）。 多个线程能并发执行。 2. 线程的生命周期线程生命周期有五种状态： 新建状态（New） 就绪状态（Runnable）： 运行状态（Running） 阻塞状态（Blocked） 死亡状态（Dead） 2.1 新建状态（New）新建了一个线程对象。 例： 123// 注：假设MyThread1类是实现了Runable接口的类MyThread1 myThread1 = new MyThread1("c");Thread thread = new Thread(myThread1); 2.2 就绪状态（Runnable）线程对象创建后，其他线程（比如主线程）调用了该线程对象的start()方法，该线程就启动了，变成Runnable状态，位于可运行线程池中，等待系统调度获取CPU使用权。 例： 1thread.start(); 2.3 运行状态（Running）Runnable状态的线程，根据系统调度获取到了CPU，于是执行run()方法，线程执行的代码都写在run()方法里。 2.4 阻塞状态（Blocked）线程因为某些原因，放弃了CPU使用权，暂停运行。 2.5 死亡状态（Dead）线程执行完了run()方法，或者因为异常退出了run()方法，该线程结束生命周期。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述Java中的内部类]]></title>
    <url>%2F2019%2F05%2F19%2F%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 简介Java内部类分为： 成员内部类 静态内部类 方法内部类 匿名内部类 2. 成员内部类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的表有哪些存储引擎以及区别]]></title>
    <url>%2F2019%2F05%2F19%2FMySQL%E7%9A%84%E8%A1%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. MySQL的表的存储引擎MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。这些不同的技术以及配套的相关功能在MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎。 常用的存储引擎有MyISAM、InnoDB、MEMORY、MERGE等。 2. MyISAM 是MySQL的默认存储引擎，使用的是表级锁。 每建立一个MyISAM存储引擎的表，都会在本地磁盘建立三个文件，比如创建了tb_demo表，则生成以下三个文件： tb_demo.frm，存储表定义。 tb_demo.MYD，存储数据。 tb_demo.MYI，存储索引。 无法处理事务。 筛选大量数据时非常迅速，这是它最突出的优点。 3. InnoDB 健壮的事务型存储引擎，使用行级锁。 适合处理多重并发的更新请求。 支持外键，MySQL支持外键的存储引擎只有InnoDB。 支持事务。 支持自动增加列AUTO_INCREMENT属性。 4. MEMORY 速度很快，为了得到最快的响应时间，数据存储在内存中，可以修改my.cnf配置文件中的max_heap_table_size参数来指定内存表的最大内存。 一般在以下情况使用MEMORY存储引擎： 目标数据较小，而且被非常频繁访问。 数据是临时的，而且要求立即可用。 数据如果突然消失，不会对应用服务产生实质的负面影响。 5. MERGE MERGE存储引擎是一组MyISAM表的组合，每张MyISAM表的结构必须相同（即每张表的字段顺序、字段名称、字段类型、索引定义的顺序及其定义的方式必须相同）。 MERGE表不存储数据，数据都存储在底层MyISAM表中。 每建立一个MERGE存储引擎的表，都会在本地磁盘建立两个文件，比如创建了tb_log表，则生成以下两个个文件，不会有.MYD和.MYI文件： tb_log.frm，存储表定义。 tb_log.mrg，存储底层MyISAM表的名字。 对MERGE表可以进行查询、更新、删除操作，实际是对底层MyISAM表进行操作。可以进行插入操作，但默认不允许，因为插入的数据不知道放在底层的哪张表里。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的排序算法]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 常见的排序算法 排序方法 平均时间复杂度 最好 最坏 空间复杂度 稳定性 冒泡排序 O(n²) O(n) O(n²) O(1) 稳定 简单选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 直接插入排序 O(n²) O(n) O(n²) O(1) 稳定 希尔排序 受增量序列影响 受增量序列影响 受增量序列影响 O(1) 不稳定 快速排序 O(nlogn) O(nlogn) O(n²) O(logn)~O(n) 不稳定 稳定性：排序前后两个相等的数相对位置不变，则算法稳定。 2. 冒泡排序2.1 过程假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 从数组最后一个元素开始与前一个元素相比较，若比前一个元素小，则交换位置。 往前对每个相邻元素都进行这样比较、交换操作，最后最小的元素冒到了数组头部，成为有序部分，有序部分的元素在之后不被比较和交换。 重复前两步骤，直到全部元素有序。 2.2 Java代码实现算法代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @ClassName: BubbleSort * @Description: 冒泡排序 * @Author: LiHaibin * @Date: 2019-05-16 10:46 * @Version: V1.0 **/public class BubbleSort &#123; /** * 从小到大的冒泡排序 * @param array */ public static void bubbleSort1(int[] array) &#123; // temp变量用于元素交换 int i, j, temp; int length = array.length; // 总共要进行length - 1轮排序 for (i = 0; i &lt; length - 1; i++) &#123; // 从最后一个元素开始比较两两比较，每轮排序要进行length - 1 - i次比较 for (j = length - 1; j &gt; i; j--) &#123; // 如果后一个元素小于前一个元素，交换这两个元素 if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; &#125; /** * 从大到小的冒泡排序 * @param array */ public static void bubbleSort2(int[] array) &#123; // temp变量用于元素交换 int i, j, temp; int length = array.length; // 总共要进行length - 1轮排序 for (i = 0; i &lt; length - 1; i++) &#123; // 从最后一个元素开始比较两两比较，每轮排序要进行length - 1 - i次比较 for (j = length - 1; j &gt; i; j--) &#123; // 如果后一个元素大于前一个元素，交换这两个元素 if (array[j] &gt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; &#125;&#125; 测试代码： 123456789101112/** * 测试冒泡排序 */@Testpublic void testBubbleSort() &#123; int[] a = &#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); BubbleSort.bubbleSort1(a); System.out.println("从小到大排序后：" + Arrays.toString(a)); BubbleSort.bubbleSort2(a); System.out.println("从大到小排序后：" + Arrays.toString(a));&#125; 2.3 算法优化可以设立flag，如果发生了交换flag设置为true，如果没有交换就设置为false。当一趟比较结束后如果flag仍为false，说明：这一趟没有发生交换，数组中的元素已经有序，没有必要继续进行下去。 优化后的算法代码： 123456789101112131415161718192021222324252627282930/** * 优化后的从小到大的冒泡排序 * @param array */public static void bubbleSort1(int[] array) &#123; // temp变量用于元素交换 int i, j, temp; // 元素是否交换的标志 boolean flag; int length = array.length; // 总共要进行length - 1趟排序 for (i = 0; i &lt; length - 1; i++) &#123; flag = false; // 每趟排序要进行length - 1 - i次比较 for (j = length - 1; j &gt; i; j--) &#123; // 如果后一个元素小于前一个元素，交换这两个元素 if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; flag = true; &#125; &#125; // if (!flag)即if (!flag == true) // 即flag == false，说明已经没有元素进行交换了，数组中的元素已经有序了，直接跳出循环 if (!flag) &#123; break; &#125; &#125;&#125; 3. 简单选择排序3.1 过程假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 第一个元素待定，在往后的元素中找出最小的元素，如果比第一个元素小，则交换。 第二个元素待定，在往后的元素中找出最小的元素，如果比第二个元素小，则交换。 依次进行下去，直到排序完成。 3.2 Java代码实现算法代码： 1234567891011121314151617181920212223242526272829303132/** * @ClassName: SelectSort * @Description: 简单选择排序 * @Author: LiHaibin * @Date: 2019-05-16 15:33 * @Version: V1.0 **/public class SelectSort &#123; /** * 从小到大的简单选择排序 * @param array */ public static void selectSort(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; // 变量minIndex用来存放最小元素下标，初始存放array[i]的下标i int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; // 如果下标与初始下标不同，则交换两个元素位置 if (minIndex != i) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; &#125;&#125; 测试代码： 12345678910/** * 测试简单选择排序 */@Testpublic void testSelectSort() &#123; int[] a =&#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); SelectSort.selectSort(a); System.out.println("从小到大排序后：" + Arrays.toString(a));&#125; 4. 直接插入排序4.1 过程直接插入排序是插入排序的一种。 假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 第一个元素已经排好序，认定为有序数组。 第二个元素插到前面的有序数组中的合适位置。 第三个元素插到前面的有序数组中的合适位置。 往后元素也依次插入有序数组的合适位置，直到整个数组有序。 4.2 Java代码实现算法代码： 123456789101112131415161718192021222324252627282930313233/** * @ClassName: InsertionSort * @Description: 直接插入排序 * @Author: LiHaibin * @Date: 2019-05-16 18:17 * @Version: V1.0 **/public class InsertionSort &#123; /** * 升序的直接插入排序 * @param array */ public static void insertionSort(int[] array) &#123; // 第一轮array[0]作为已经排序好的元素 // 总共要进行array.length - 1轮的插入 for (int i =0; i &lt; array.length - 1; i++) &#123; // array[i + 1]作为将要插入的元素，依次与前面的以排序好的元素比较 for (int j = i + 1; j &gt; 0; j--) &#123; // 比前面元素小则交换位置，然后继续比较 if (array[j] &lt; array[j - 1]) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; // 否则当前一轮已经有序，直接跳出循环，进行下一轮插入 else &#123; break; &#125; &#125; &#125; &#125;&#125; 测试代码： 12345678910/** * 测试插入排序 */@Testpublic void testInsertionSort() &#123; int[] a = &#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); InsertionSort.insertionSort(a); System.out.println("升序排序后：" + Arrays.toString(a));&#125; 5. 希尔排序（Shell Sort）5.1 过程希尔排序也是插入排序一种。 假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 设置第一个增量 = 数组长度 / 2，然后按增量分组，如数组{9， 2， 6， 3， 10， 5， 7， 11}，则第一个增量为4，则9、10为一组；2、5为一组；6、7为一组；3、11为一组。每组各自进行直接插入排序。 设置第二个增量 = 第一个增强 / 2，然后按增量分组，各组各自进行直接插入排序。 直到设置到增量 = 1，最后直接对整个数组进行直接插入排序。 希尔排序时间复杂度受增量序列的影响。 5.2 Java代码实现算法代码： 123456789101112131415161718192021222324252627282930313233/** * @ClassName: ShellSort * @Description: 希尔排序 * @Author: LiHaibin * @Date: 2019-05-17 14:21 * @Version: V1.0 **/public class ShellSort &#123; /** * 升序的希尔排序 * @param array */ public static void shellSort(int[] array) &#123; // 初始增量为length/2，随后再/2，直到增量为1 for (int gap = array.length / 2; gap &gt; 0; gap /= 2) &#123; // 从array[gap]开始，逐个对其所在组进行直接插入排序 for (int i = gap; i &lt; array.length; i++) &#123; // 直接插入排序 for (int j = i; j &gt;= gap; j -= gap) &#123; if (array[j] &lt; array[j - gap]) &#123; int temp = array[j - gap]; array[j - gap] = array[j]; array[j] = temp; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125;&#125; 测试代码： 12345678910/** * 测试希尔排序 */@Testpublic void testShellSort() &#123; int[] a = &#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); ShellSort.shellSort(a); System.out.println("升序排序后：" + Arrays.toString(a));&#125; 5. 快速排序（Quick Sort）5.1 过程假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 先选择一个元素设为枢轴（pivot），一般我们选择数组第一个元素。 先从最右往左遍历，直到遇到小于枢轴的元素，交换这个元素和枢轴元素的位置。 再从左往右遍历（交换过的位置和遍历过的位置都不再遍历），直到遇到大于等于枢轴的元素，交换这个元素和枢轴元素的位置。 重复以上两步骤，直到元素都被遍历。 继续划分枢轴左右两边的数组，继续递归以上操作。 可能你还是有点迷糊，请看下面一张图，胜过千言万语： ps：以下图以数组最后一个元素设为枢轴，和我的操作稍微有点不同，但思想还是一样的。 5.2 Java代码实现算法代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @ClassName: QuickSort * @Description: 快速排序 * @Author: LiHaibin * @Date: 2019-05-17 19:12 * @Version: V1.0 **/public class QuickSort &#123; /** * 一轮递归 * @param array * @param left * @param right */ public static int divide(int[] array, int left, int right) &#123; // 每次都将数组最左边的元素设置为枢轴（pivot） // pivot变量只是用作存储枢轴的值，用于下面比较大小 int pivot = array[left]; // left指向最左元素，right指向最右元素 while (left &lt; right) &#123; while (array[right] &gt;= pivot &amp;&amp; left &lt; right) &#123; right--; &#125; // 上面循环结束就说明当前array[right] &lt; 枢轴的值，要将数组中这两元素位置交换 if (left &lt; right) &#123; int temp = array[right]; array[right] = array[left]; array[left] = temp; // 当前left指针指向的元素及以前的元素都已经比枢轴小，所以left指针要后移一位 left++; &#125; while (array[left] &lt; pivot &amp;&amp; left &lt; right) &#123; left++; &#125; // 上面循环结束就说明当前array[left] &gt;= 枢轴的值，要将数组中这两元素位置交换 if (left &lt; right) &#123; int temp = array[left]; array[left] = array[right]; array[right] = temp; right--; &#125; &#125; // 返回left或者right都可以，因为两指针指向同一元素，即枢轴元素 return left; &#125; /** * 升序的快速排序 * @param array * @param left * @param right */ public static void quickSort(int[] array, int left, int right) &#123; if (right &gt; left) &#123; int mid = divide(array, left, right); // 继续划分枢轴左右两边的数组，继续递归下去 quickSort(array, left, mid - 1); quickSort(array, mid + 1, right); &#125; &#125;&#125; 测试代码: 12345678910/** * 测试快速排序 */@Testpublic void testQuickSort() &#123; int[] a = &#123;2, 7, 4, 5, 10, 1, 9, 3, 8, 6&#125;; System.out.println("排序前：" + Arrays.toString(a)); QuickSort.quickSort(a, 0, a.length - 1); System.out.println("升序排序后：" + Arrays.toString(a));&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述TCP和UDP的区别]]></title>
    <url>%2F2019%2F05%2F15%2F%E7%AE%80%E8%BF%B0TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. TCP报文格式 2. UDP报文格式 3. 区别 TCP： TCP提供一种面向连接的面向字节流的服务。 TCP提供可靠交付。 TCP只能一对一连接，不提供广播或多播。 TCP对资源开销大。 UDP： UDP提供无连接的面向报文的服务。 UDP不保证可靠交付。 UDP支持一对一，一对多，多对一，多对多的交互通信。 UDP资源开销小。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述TCP三次握手和四次挥手]]></title>
    <url>%2F2019%2F05%2F14%2F%E7%AE%80%E8%BF%B0TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[1. TCP简介 TCP提供一种面向连接的、可靠的字节流服务。 每一条TCP连接只能有两个端点，是一对一的，广播和多播不能用于 TCP。 TCP提供超时重发、丢弃重复数据、校验数据、流量控制等功能。 2. TCP报文格式如图所示： TCP报文首部有几个部分重点关注： 序号字段（Sequence Number）：占32位（4字节），TCP连接中传送的数据流每一个字节都编上一个序号，序号字段的值表示本报文所发送的数据的第一个字节的序号。 确认号字段（Acknowledgement Number）：占32位（4字节），是期望收到对方下一个报文的数据的第一个字节的编号。 标志字段：共6个，URG、ACK、PSH、RST、SYN、FIN。 URG：URG=1时，表明紧急指针字段有效，此报文有紧急数据，应尽快传送。 ACK：ACK=1时，确认号字段才有效。 PSH：PSH=1时，接收方应该尽快将这个报文交给应用层。 RST：RST=1时，表明TCP连接出现严重差错，重置连接。 SYN：SYN=1时，表明这是一个连接请求（SYN）报文或者连接接受（SYN+ACK）报文。 FIN：FIN=1时，表明是FIN报文，释放连接。 3. TCP连接的建立与释放TCP的连接有三个阶段：连接建立、数据传输和连接释放。 3.1 连接建立（三次握手） 第一次握手：客户端发送一条SYN报文到服务器端，该报文SYN=1，序号（Sequence Number）=x。 第二次握手：服务器端发送一条（SYN+ACK）报文回客户端，该报文SYN=1、ACK=1，序号（Sequence Number）=y、确认号（Acknowledgement Number）=x+1。 第三次握手：客户端发送ACK报文回服务器端，该报文ACK=1，序号（Sequence Number）=x+1、确认号（Acknowledgement Number）=y+1。 此时TCP连接便已经建立，进行数据传输。 注意：发送SYN=1报文或者FIN=1报文虽然不携带数据，但仍然要消耗一个序号；ACK报文可以携带数据，如果不携带数据不消耗序号。 3.2 数据传输数据传输。 3.3 连接释放（四次挥手）客户端和服务器端双方都可以发起连接释放请求，这里假设客户端发起连接释放请求。 第一次挥手：客户端发送一条FIN报文到服务器端，该报文FIN=1，序号（Sequence Number）=u。意思是我客户端没有数据要发给你了，通知对方要释放从客户端到服务器端这个方向的连接。 第二次挥手：服务器端发送ACK报文回客户端，该报文ACK=1，序号（Sequence Number）=v，确认号（Acknowledgement Number）=u+1。此时从客户端到服务器端这个方向的连接释放，但服务器端仍然可以发送数据到客户端。 第三次挥手：服务器端发送FIN+ACK报文回客户端，该报文FIN=1、ACK=1，序号（Sequence Number）=w、确认号（Acknowledgement Number）=u+1。意思是服务器端到客户端的数据也发送完毕了，准备好释放连接了。 第四次挥手：客户端发送ACK报文回服务器端，该报文ACK=1，序号（Sequence Number）=u+1、确认号（Acknowledgement Number）=w+1。服务器端收到ACK报文后便CLOSED；而客户端进入TIME-WAIT，等待2MSL（Maximum Segment Lifetime）后如果依然没收到服务器端的ACK回复，则证明服务器端确实CLOSED，那么客户端也CLOSED。 此时TCP连接全部释放完毕。 4. 问题4.1 问题一 为什么TCP三次握手而不是两次握手？ 主要为了防止已经失效的SYN报文（连接请求报文）突然又传送到了服务器端，造成了连接的误判而使服务器资源浪费。 例： 客户端发送了SYN报文A到服务器端，但由于某些原因SYN报文A在网络上滞留了，所以客户端又超时重发了SYN报文B到服务器端，而后正常的连接建立、数据传输和连接释放。此时滞留的SYN报文A发到了服务器端，这是一个已经失效的报文，假设没有第三次握手，服务器端发送（SYN+ACK）报文回客户端后便建立了连接，但由于客户端认为自己没有发送SYN报文请求连接，所以不理会服务器端，也不传输数据给服务器端，白白造成服务器资源浪费。第三次握手就是为了避免这种情况。 4.2 问题二 TCP三次握手的缺陷？ 服务器端维护两个队列：syns queue（半连接队列）、accept queue（全连接队列）。 第一次挥手中，服务器端收到客户端的SYN报文后，就把相关信息放到半连接队列中。随后第二次挥手，服务器端发送（SYN+ACK）报文回客户端。第三次挥手服务器端收到客户端的ACK报文后，就把半连接队列里的相关信息拿出来放到全队列连接里。 SYN-Flood攻击就是攻击者伪造IP地址对服务器不停发SYN报文，而故意不理会服务器发送回的（SYN+ACK）报文，从而占满服务器的半连接队列。另一方面，真实的IP会认为我没有发送SYN报文，不理会，服务器没收到客户端的ACK报文，就不知道自己的（SYN+ACK）报文是否发送成功，一直重发，对服务器资源造成极大浪费。 4.3 问题三 为什么第四次挥手后会有TIME-WAIT状态？ 防止第四次挥手发送的ACK报文丢失（防止对方没有收到第四次挥手发送的ACK报文），所以进入TIME-WAIT状态，等待2MSL后，如果依然没收到对方发送回的ACK报文，则确定对方CLOSED，那么自己也CLOSED。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的异常]]></title>
    <url>%2F2019%2F05%2F14%2FJava%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1. Java中异常的结构Throwable类是所有异常的父类，它有两个子类，Error类和Exception类。 查看继承关系图： 2. Error类Error类及其子类都是程序无法处理的错误，大多数错误与代码编写者执行的操作无关，如VirtualMachineError、ThreadDeath等，这些异常发生时，只能交由JVM（Java虚拟机）处理，JVM一般会选择线程终止。 3. Exception类Exception是程序本身可以处理的异常，Exception又分为两种，一种是运行时异常，另一种是非运行时异常： 运行时异常：都是RuntimeException及其子类，如IndexOutOfBoundsException（下标越界异常）、NullPointerException（空指针异常）等，这些异常大多数是由程序逻辑错误引起，这些都是不检查异常，可以选择捕获处理，也可以不处理。 非运行时异常：RuntimeException以外的异常，是受检查异常，必须进行捕获处理，如果不进行捕获处理，编译不能通过，如常见的IOException及其子类，SQLException及其子类等，或者是自定义的异常（当然一般情况不会自定义受检查异常）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java重载与重写]]></title>
    <url>%2F2019%2F05%2F14%2FJava%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[1. 重载可以理解为一个类中方法的多态，就是多个具有不同参数个数、不同参数类型的同名方法同时存在在一个类中。调用方法通过传递不同参数个数及类型来决定调用哪个方法。 2. 重写子类中一个方法与父类的某一方法有相同方法名、返回类型和参数，则子类方法覆盖原有的继承自父类的方法。这称为方法重载，需要在子类方法上添加@Override注解。如需要再用到父类方法，可用super关键字：super.方法名。 3. 区别 重载由静态类型确定，在类加载时即可确定，属于静态分派。 重写由动态类型确定，是在运行时确定的，属于动态分派。动态分派由虚方法表实现，虚方法表中存在着各个方法的实际入口地址 若子类没重写，则父类和子类的方法表中方法地址相同； 若子类重写了，则子类方法表的方法地址指向重写后的地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java用自定义类作为HashMap的键]]></title>
    <url>%2F2019%2F05%2F14%2FJava%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Java用自定义类作为HashMap的键，在自定义类中重写哪些方法？ 必须要重写hashCode()方法和equals()方法。 自定义类中的hashCode()方法和equals()方法都继承自Object类： Object类的hashCode()方法返回这个对象存储的内存地址的编号。 Object类的equals()比较的是内存地址是否相等。 HashMap中比较key是这样的： 先用hashCode()方法比较两个key的hash值，若相等 再用equals()方法比较两个key的对象是否相等，全部相等才能视为两个key相等。 现实中我们比较，例如定义了一个学生类，有学号属性，只要学号一样，即使是生成了两个对象，但我们也认为是同一个学生。所以我们判断的是逻辑上的相等，而不是内存地址上的相等，所以要重写hashCode()方法和equals()方法。 ps：用String类型作为HashMap的键为什么没有问题呢？ 查看String类源码可发现，其实String类已经重写了hashCode()方法和equals()方法，这是JDK已经帮我们实现了的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[char可以储存汉字吗]]></title>
    <url>%2F2019%2F05%2F13%2Fchar%E5%8F%AF%E4%BB%A5%E5%82%A8%E5%AD%98%E6%B1%89%E5%AD%97%E5%90%97%2F</url>
    <content type="text"><![CDATA[char可以储存汉字吗？ 当然可以，Java中char型变量是用来储存Unicode编码字符的，Unicode编码字符集中包含了汉字，所以可以储存汉字。Unicode编码占用两个字节，所以char类型变量也占用两个字节。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Object类中有哪些方法]]></title>
    <url>%2F2019%2F05%2F13%2FJava-Object%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java Object类中有哪些方法？ hashCode、equals、clone、toString、notify、notifyAll、wait、finalize等。 Object类源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package java.lang;/** * Class &#123;@code Object&#125; is the root of the class hierarchy. * Every class has &#123;@code Object&#125; as a superclass. All objects, * including arrays, implement the methods of this class. * * @author unascribed * @see java.lang.Class * @since JDK1.0 */public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中抽象类与接口的区别]]></title>
    <url>%2F2019%2F05%2F13%2FJava%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. 抽象类抽象类：如果一个类中有抽象方法，那么这个类就是抽象类，抽象类必须用abstract关键字修饰。 抽象方法只声明，无具体实现。 抽象类和抽象方法必须被public或protected修饰（如果是private，则不能被子类访问到，自然无法被继承也无法被子类实现抽象方法），缺省情况下默认为public。 不能用抽象类创建对象。 如果一个子类继承一个抽象类的父类，那么子类必须实现父类的所有抽象方法，如果不全部实现，这个子类任然是抽象类，必须仍然用abstract关键字修饰。 2. 接口接口：用interface定义。 接口中所有方法都必须是抽象方法，缺省被public abstract修饰，且只能被public abstract修饰。（推荐缺省即不加修饰词，使代码简洁美观）。 接口中可以有变量，缺省被public abstract final修饰，且只能被public abstract final修饰，即变量必须给初值且不可更改。一般情况下不会在接口中定义变量。 3. 抽象类和接口的区别 抽象类在Java中表示继承关系，只能单继承，class B extends A {} 接口也能继承接口，不需要实现父接口方法，且一个接口能继承多个接口，interface C extends A, B {} 一个类可以单继承，多接口实现，class E extends D implements A, B, C {} 抽象类中可以有非抽象方法，接口中必须全部为抽象方法。 抽象类中可以有static方法（static方法是类方法，不允许子类override），接口中不能有static方法，只能是public abstract方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之Iterator（迭代器）]]></title>
    <url>%2F2019%2F05%2F09%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Iterator（迭代器）1.1 简介迭代器作用于集合，是用来遍历集合元素的对象。 1.2 IteratorIterator（迭代器）源自package java.util.Iterator,它是一个接口，源码如下： 12345678910111213141516public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 其中： E next()：返回迭代的下一个元素，返回值是 Object，需要强制转换成自己需要的类型。（如果使用泛型如Iterator&lt;String&gt; iterator = list.iterator()之后返回值会从Object改为指定的引用类型） boolean hasNext()：判断是否还有元素。 default void remove()：删除新返回的元素。 1.3 IterableIterable源自package java.lang.Iterable，它也是一个接口，源码如下： 123456789101112131415public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 该接口定义了方法Iterator&lt;T&gt; iterator()，返回值为迭代器对象，Collection接口继承了Iterable接口，而ArrayList、HashSet等实现类都实现了Collection接口，所以这些实现类的对象均可以.iterator()来创建Iterator对象。 以ArrayList为例查看继承关系： 1.4 以ArrayList为例演示Iterator的用法阿里巴巴Java开发手册强制规定了不要在 foreach 循环里进行元素的 remove/add 操作，remove 元素请使用 Iterator方式。 代码示例： 12345678910111213141516171819202122232425262728@Testpublic void testIterator() &#123; // 新建ArrayList对象并添加元素 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aa"); list.add("bb"); list.add("cc"); System.out.println(list); // 字符串对象，用于以下条件判断 String s = "aa"; // ArrayList对象以.iterator()来创建Iterator对象且指定了泛型为String Iterator&lt;String&gt; iterator = list.iterator(); // 判断是否还有元素 while (iterator.hasNext()) &#123; // 返回迭代的下一个元素 String item = iterator.next(); // 条件判断 if (s.equals(item)) &#123; // 移除刚返回的元素 iterator.remove(); &#125; &#125; System.out.println(list);&#125; 控制台打印信息：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Redis]]></title>
    <url>%2F2019%2F05%2F04%2FSpring-Boot%E6%95%B4%E5%90%88Redis%2F</url>
    <content type="text"><![CDATA[1. Redis简介 在实际开发中，一般使用缓存中间件：redis、ehcache、memcache；导入了对应的组件依赖，就可以使用对应的缓存。 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 我使用Redis作为缓存中间件。 2. 安装Redis服务和客户端2.1 Redis中文官网http://www.redis.cn/ 提供了各种对Redis的支持和参考文档以及下载，遇到问题时可以访问此网站寻求解决方法。 2.2 下载与安装 Linux版本：http://download.redis.io/releases/ Windows版本：https://github.com/MicrosoftArchive/redis/releases 我在win机上测试，下载win版，解压然后运行redis-server.exe即可。 若服务无法运行或者闪退，请参考： https://fuyuanyua.github.io/2019/04/27/redis-server-exe%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ Redis服务启动成功： 安装 Redis 可视化客户端 redis-desktop-manager-0.8.8.384.exe。 运行redis-desktop-manager。 连接Redis服务，名字任取，Host即127.0.0.1即localhost，端口号默认6379。 连接成功。 至此Redis服务与客户端已经全部安装运行完成。 3. Redis支持的数据结构3.1 常用五种数据结构 String：&lt;key, value&gt; Hash：&lt;key，fields-values&gt; List：有顺序可重复 Set：无顺序不可重复 Sorted Sets (zset) ：有顺序，不能重复 常用五种，当然还有更多数据结构请参考： http://www.redis.cn/commands.html 3.2 String：&lt;key, value&gt; set：设置key和value。 12MyRedis:0&gt;set A hello&quot;OK&quot; get：获取指定key的value。 12MyRedis:0&gt;get A&quot;hello&quot; append：追加值。 1234MyRedis:0&gt;append A world&quot;10&quot;MyRedis:0&gt;get A&quot;helloworld&quot; incr：整数值加1。 12MyRedis:0&gt;incr A&quot;ERR value is not an integer or out of range&quot; A不是整型，所以无法执行原子加1操作。 1234567891011MyRedis:0&gt;set B 1&quot;OK&quot;MyRedis:0&gt;get B&quot;1&quot;MyRedis:0&gt;incr B&quot;2&quot;MyRedis:0&gt;get B&quot;2&quot; B是整型，执行原子加1操作。 decr：整数值减1。 12345MyRedis:0&gt;decr B&quot;1&quot;MyRedis:0&gt;get B&quot;1&quot; keys *：查看所有key。 123MyRedis:0&gt;keys * 1) &quot;B&quot; 2) &quot;A&quot; del key_name：删除指定key和他对应的value。 12MyRedis:0&gt;del B&quot;1&quot; 更多语法请参考： http://www.redis.cn/commands.html#string 3.3 Hash：&lt;key，fields-values&gt;相当于一个key对于一个Map，Map中还有key-value, 使用hash对key进行归类。 hset： 12345678MyRedis:0&gt;hset myhash a1 1&quot;1&quot;MyRedis:0&gt;hset myhash a2 2&quot;1&quot;MyRedis:0&gt;hset myhash a3 3&quot;1&quot; hget： 12MyRedis:0&gt;hget myhash a2&quot;2&quot; hgetall key_name：获取指定key的hash中所有key-value。 1234567MyRedis:0&gt;hgetall myhash 1) &quot;a1&quot; 2) &quot;1&quot; 3) &quot;a2&quot; 4) &quot;2&quot; 5) &quot;a3&quot; 6) &quot;3&quot; 更多语法请参考： http://www.redis.cn/commands.html#hash 3.4 List：有顺序可重复 lpush：向左边添加值。 12MyRedis:0&gt;lpush mylist a b c d&quot;4&quot; lrange：获取指定key的list的所有值（0表示下标从0开始，-1表示获取所有）。 12345MyRedis:0&gt;lrange mylist 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; rpush：向右边添加值。 lpop：弹出左边第一个值。 rpop：弹出右边的第一个值。 12345678910111213141516MyRedis:0&gt;rpush mylist e f g&quot;7&quot;MyRedis:0&gt;lrange mylist 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;e&quot; 6) &quot;f&quot; 7) &quot;g&quot;MyRedis:0&gt;lpop mylist&quot;d&quot;MyRedis:0&gt;rpop mylist&quot;g&quot; 更多语法请参考： http://www.redis.cn/commands.html#list 3.5 Set：无顺序不可重复 sadd： 12MyRedis:0&gt;sadd myset a b c d e&quot;5&quot; smembers： 123456MyRedis:0&gt;smembers myset 1) &quot;c&quot; 2) &quot;d&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;e&quot; srem：移除指定元素 1234567MyRedis:0&gt;srem myset a&quot;1&quot;MyRedis:0&gt;smembers myset 1) &quot;d&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;e&quot; 更多语法请参考： http://www.redis.cn/commands.html#set 3.6 Sorted Sets (zset) ：有顺序，不能重复 zadd key score member：将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置，按成员得分由小到大排列。 12MyRedis:0&gt;zadd myzset 1 a 2 b 3 c&quot;3&quot; zrange： 1234567891011121314151617181920212223MyRedis:0&gt;zadd myzset 1 d 1 e&quot;2&quot;MyRedis:0&gt;zrange myzset 0 -1 1) &quot;a&quot; 2) &quot;d&quot; 3) &quot;e&quot; 4) &quot;b&quot; 5) &quot;c&quot;MyRedis:0&gt;zadd myzset 10 a&quot;0&quot;MyRedis:0&gt;zrange myzset 0 -1 withscores 1) &quot;d&quot; 2) &quot;1&quot; 3) &quot;e&quot; 4) &quot;1&quot; 5) &quot;b&quot; 6) &quot;2&quot; 7) &quot;c&quot; 8) &quot;3&quot; 9) &quot;a&quot; 10) &quot;10&quot; 更多语法请参考： http://www.redis.cn/commands.html#sorted_set]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot项目部署到云服务器]]></title>
    <url>%2F2019%2F05%2F02%2FSpring-Boot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 打包本地项目1.1 打包将本地Spring Boot项目以jar包形式打包。 IDEA最右侧栏点击Maven Projects。 找到要打包的项目，Lifecycle→package→Run Maven Build。 显示如下说明打包成功。 可在项目目录下的target目录下找到打包好的jar包。 1.2 本地测试cmd 进入jar包所在目录，运行jar包启动项目，指定80端口号，直接访问localhost或者127.0.0.1（等同于localhost）即可。 12F:\Users\Administrator\IdeaProjects\spring-boot-10-bill\target&gt;java -jar spring-boot-10-bill-0.0.1-SNAPSHOT.jar --server.port=80 2. 阿里云服务器2.1 简介阿里云官网网站：https://www.aliyun.com/ 2.2 购买先进行学生认证，然后购买仅需9.5元一个月，十分优惠。 我购买的阿里云服务器为CentOS 7.3 64位系统（什么是CentOS：https://zh.wikipedia.org/wiki/CentOS ）。 2.3 开放端口添加安全组规则，开放8080端口、80端口和3306端口。 3. 阿里云服务器安装MySQL3.1 参考安装Linux版MySQL5.7。 具体参考：https://www.jellythink.com/archives/14 4. 阿里云服务器安装JDK1.84.1 上传解压 用FileZilla（什么是FileZilla：https://themebetter.com/ftp-filezilla.html ）将 JDK安装包上传到服务器 /opt目录里面 ，右键选择上传即可。 使用secureCRT（什么是secureCRT：https://blog.csdn.net/liwf_/article/details/9429349 ）连接阿里云服务器，解压文件。 12# cd /opt # tar -zxvf JDK的文件名 ls 查看解压后的JDK。 将JDK移动到/home目录。 1# mv jdk1.8.0_171/ /home/ 4.2 配置环境变量 用vim编辑器编辑profile文件。 1# vim /etc/profile 在末尾行添加，打开后按i编辑, 按ctrl+c停止编辑，然后 :wq 保存退出。 12export JAVA_HOME=/home/jdk1.8.0_171export PATH=$PATH:$JAVA_HOME/bin: 使更改的配置立即生效。 1# source /etc/profile 查看JDK版本信息 1# java -version 此结果说明JDK安装配置成功。 5. 运行5.1 阿里云服务器MySQL建表使用MySQL Workbench访问阿里云上的数据库，建项目所需要的表。 5.2 设置MySQL开机自启动使用secureCRT设置阿里云服务器上MySQL开机自启动。 1# chkconfig mysqld on 5.3 运行项目 先用FileZilla将本地打包好的项目jar包推送到阿里云服务器。 然后用secureCRT在阿里云服务器上以后台进程并用80端口运行项目。 1# nohup java -jar 项目jar包名 --servre.port=80 &amp; 至此已经将项目在阿里云服务器全部部署完成，理论上访问阿里云服务器的IP地址，便可以成功访问本项目。 5.4 一些小问题 Linux下MySQL中文乱码（全部显示问号）， 请参考：https://blog.csdn.net/leen0304/article/details/80534609 网页响应特别慢， 请参考：https://www.cnblogs.com/zhangyuejia/p/8575080.html]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的常用命令]]></title>
    <url>%2F2019%2F05%2F02%2FLinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. Linux的常用命令 进入指定目录，cd即change directory的缩写。 1# cd /xx/xx 进入用户主目录，即HOME变量指定的目录，如root用户的主目录为/root。 1# cd ~ 或 1# cd 返回上一级目录。 1# cd .. 查看当前目录下所有文件。 1# ls 解压压缩包到当前目录下（按Tab键可以快速补全文件名）。 1# tar -zxvf 文件名 移动指定文件或目录到指定目录下。 1# mv /xx/xx /xx/xx 用vim编辑器编辑指定文件。 1# vim /xx/xx 进入文件后： 按i：切换到输入模式，以输入字符。 按ctrl+c：暂停。 暂停后： 按:w：保存文件但不退出vim。 按:wq：保存文件并退出vim。 按:q：不保存文件，退出vim。 按:q!：不保存文件，并强制退出vim。 重新执行刚修改的初始化文件，使之立即生效。 1# source 文件名 启动以jar包形式打包的java项目。 1# java -jar 项目jar包名 以80端口启动jar包形式的java项目。 1# java -jar 项目jar包名 --servre.port=80 以后台进程运行项目。 1# nohup java -jar 项目jar包名 --servre.port=80 &amp; 查看所有java进程。 1# ps -ef|grep java 停止所有java进程。 1# pkill -9 java 停止指定java进程。 1# kill -9 java进程序号 连接本地主机mysql。 1# mysql -u 用户名 -p 密码 一般都是： 1# mysql -u root -p 随后输入密码即可进入mysql。 连接远程主机mysql。 1# mysql -h 远程主机IP地址 -u 用户名 -p 密码 未完待续…]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-server.exe启动失败解决方案]]></title>
    <url>%2F2019%2F04%2F27%2Fredis-server-exe%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天我下载了Win版的Redis，解压缩后，双击redis-server.exe，屏幕一闪而过，启动失败，查阅网上资料后找到解决办法。 win+R打开cmd命令。 进入F盘：f: cd到Redis包目录下：cd F:\redis\Redis-x64-3.2.100（在当前目录的地址栏直接输入cmd，可直接进入，更方便） 输入：redis-server.exe redis.windows.conf 启动成功]]></content>
      <categories>
        <category>小坑</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot缓存操作]]></title>
    <url>%2F2019%2F04%2F25%2FSpring-Boot%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 缓存1.1 简介在开发中，如果有经常频繁访问的数据，那么一般都使用缓存，以此来减少访问数据库，减轻压力。 1.2 引入缓存启动器依赖pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 1.3 application.yml全局配置文件创建数据库bill并在user表中添加几条数据。 然后配置application.yml： 12345678910111213141516spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/bill?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver# com.example.springboot.mapper.UserMapper包下打印日志级别为debuglogging: level: com.example.springboot.mapper.UserMapper: debug# 开启自动驼峰命名方式mybatis: configuration: map-underscore-to-camel-case: true 1.4 @EnableCaching注解在启动类上使用注解@EnableCaching以开启注解版缓存。 12345678910@EnableCaching //开启注解版缓存@MapperScan("com.example.springboot.mapper")@SpringBootApplicationpublic class SpringBoot13CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot13CacheApplication.class, args); &#125;&#125; 1.5 @Cacheable注解@Cacheable注解标注在方法上（一般写在Service层），该方法的返回结果就会进行缓存。 把缓存理解为一个“缓存容器”，里面有一条条key，每个key对应的value为方法返回的值。 @Cacheable的属性： cacheNames指定“缓存容器”的名字。 key指定缓存中的key值，key = &quot;#id&quot;即将方法中的参数id当做key。 Service层中代码示例： 1234567891011/** * cacheNames：缓存容器名字 * key：缓存容器中的key值，方法返回值为value值 * @param id * @return */@Cacheable(cacheNames = "user", key = "#id")public User getUserById(Integer id) &#123; User user = userMapper.getUserById(id); return user;&#125; 1.6 @CachePut注解@CachePut注解保证了修改了表中的数据后，同时更新缓存中的数据，使得别人查询这条已更新的数据直接从缓存中获取。 测试： 先查询id=1的用户，数据会放在缓存中。 后面查询id=1的用户数据都从缓存中获取。 更新id=1的用户，同时会更新缓存中的数据。 后面查询id=1的用户数据依然直接从缓存中获取。 Service层中代码示例： 1234567@CachePut(cacheNames = "user", key = "#user.id")//cacheNames = "user" 必须指定一个缓存的名称，不然报500错误//缓存都是在调用方法之后执行，而不是调用方法之前执行public User updateUser(User user) &#123; userMapper.updateUser(user); return user;&#125; 1.7 @CacheEvict注解默认情况下删除数据不会将缓存中的数据删除，使用@CacheEvict注解，使得删除数据的同时也将缓存中的数据删除。 @CacheEvict的属性： cacheNames指定“缓存容器”的名字。 key指定缓存中的key值，key = &quot;#id&quot;即将方法中的参数id当做key。 allEntries = true 会将缓存中所有数据清除，默认false。 beforeInvocation = true 在调用方法之前清理缓存，默认false（在调用方法之后再清理缓存）。 Service层中代码示例： 123456789101112/** * 默认情况下删除数据不会将缓存中的数据删除 * allEntries = true 会将缓存中所有数据清除，默认false * beforeInvocation = true 在调用方法之前清理缓存，默认false（在调用方法之后再清理缓存） * @param id * @return */@CacheEvict(cacheNames = "user", key = "#id", allEntries = true, beforeInvocation = true)public Integer deleteUserById(Integer id) &#123; userMapper.deleteUserById(id); return id;&#125; 1.8 @CacheConfig注解@CacheConfig(cacheNames = &quot;user&quot;)配置了该类下所有方法的缓存名都为”user”，这样就不用在下面每个方法的注解上指定cacheNames = &quot;user&quot;了。 代码示例： 1234567891011121314151617181920@CacheConfig(cacheNames = "user")//此注解配置了类下所有方法缓存名都为"user",就不用在下面每个方法的注解上指定cacheNames = "user"了@Servicepublic class UserService &#123; @Autowired UserMapper userMapper; /** * cacheNames：缓存容器名字 * key：缓存容器中的key值，方法返回值为value值 * @param id * @return */ @Cacheable(/*cacheNames = "user",*/ key = "#id") public User getUserById(Integer id) &#123; User user = userMapper.getUserById(id); return user; &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.04.21-23上海旅行规划]]></title>
    <url>%2F2019%2F04%2F20%2F2019-04-21-23%E4%B8%8A%E6%B5%B7%E6%97%85%E8%A1%8C%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[2019.04.21上午： 宁波（09:54）——上海虹桥（12:10） 中午： 午餐 富贵面馆 牛蛙面 安顺路175号 地铁10号线（虹桥火车站上，虹桥路下） 下午： 上海当代艺术博物馆 门票20元起 黄浦区苗江路678号 地铁4号线外圈（虹桥路上，西藏南路下） INVINCIBLE 鞋店 SOHO复兴广场，马当路388号103 地铁8号线（西藏南路上，老西门下），地铁10号线（老西门上，新天地下） CONCEPTS 鞋店 上海新天地，兴业路123弄2 步行 DOE 鞋店 黄浦区湖滨路168号 步行 晚餐 SHAKE SHACK 汉堡 上海新天地，太仓路181弄10号 步行 晚上： 南京东路 上海001，南京路步行街，外滩，上海市人民英雄纪念塔 地铁1号线（黄陂南路上，人民广场下） 回家 徐汇区复兴中路1218弄 地铁10号线（南京东路上，陕西南路下） 2019.04.22上午： 早餐 暂定 甜爱路 甜爱路，鲁迅纪念馆，多伦路文化名人街 地铁1号线（陕西南路上，人民广场下），地铁8号线（人民广场上，虹口足球场下） 中午： 午餐 蟹黄鱼 黄浦区太仓路200号一层B区 地铁8号线（虹口足球场上，人民广场下），地铁1号线（人民广场上，黄陂南路下） 下午： 武康路 武康大楼，巴金故居，法租界 地铁1号线（黄陂南路上，陕西南路下），地铁10号线（陕西南路上，交通大学下） JUICE SH 鞋店 静安区巨鹿路832号 步行或骑车 暂定 暂定 暂定 暂定 晚餐 暂定 暂定 暂定 晚上： Troye Sivan演唱会 开始时间（20:00） 上海梅赛德斯奔驰文化中心 视情况而定 暂定可选 哈灵面馆（牛蛙面） 鲜得来（排骨年糕） 红宝石（奶油小方，栗子蛋糕） 平成屋日料]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot邮件操作]]></title>
    <url>%2F2019%2F04%2F19%2FSpring-Boot%E9%82%AE%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 简单邮件1.1 引入邮件依赖新建项目时在引入依赖时勾选I/O中的Mail选项，项目创建好后查看pom.xml文件有此依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 配置application.yml文件以qq邮箱为例， spring.mail.username为邮箱名，已打码。 spring.mail.password为授权第三方登录的密码。 设置发送邮件的服务器。 设置SSL连接为true。 123456789# 配置邮箱信息spring: mail: username: xxxxxxxxx@qq.com password: sroomflkeutvbbfj # 发送邮件服务器 host: smtp.qq.com # SSL连接 properties.smtp.ssl.enable: true 1.3 测试类 @Autowired JavaMailSenderImpl javaMailSender;注入JavaMailSenderImpl。 SimpleMailMessage类 封装了简单邮件。 simpleMailMessage.setFrom()发送方邮箱，已打码。 simpleMailMessage.setTo()接收方邮箱，已打码。 1234567891011121314151617181920212223@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot12MailApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; //简单邮件测试 @Test public void testSimpleMail() &#123; //SimpleMailMessage类，封装简单邮件 SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); //设置邮件主题（标题） simpleMailMessage.setSubject("标题测试"); //设置邮件正文 simpleMailMessage.setText("正文测试"); //设置发件人 simpleMailMessage.setFrom("xxxxxxxxx@qq.com"); //设置收件人 simpleMailMessage.setTo("xxxxxxxxx@gmail.com"); javaMailSender.send(simpleMailMessage); &#125;&#125; 1.4 运行接收方邮箱便能收到这份简单邮件。 2. 复杂邮件2.1 引入邮件依赖同1.1，略。 2.2 配置application.yml文件同1.2，略。 2.3 测试类 MimeMessage类的对象不能直接设置标题正文等发送内容。 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);需要通过MimeMessageHelper类的对象来设置发送内容。 mimeMessageHelper.setText()第二个参数设置为true，才能使用html代码。 mimeMessageHelper.addAttachment()设置附件，第一个参数指定附件名。 1234567891011121314151617181920212223242526@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot12MailApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; //复杂邮件测试 @Test public void testMimeMail() throws MessagingException &#123; //MimeMessage类 MimeMessage mimeMessage = javaMailSender.createMimeMessage(); //通过MimeMessage帮助对象 来设置发送内容，第二个参数为true表示可以发送附件 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); //设置邮件主题（标题） mimeMessageHelper.setSubject("标题测试1"); //设置邮件正文,第二个参数设置为true，才可以发送html代码 mimeMessageHelper.setText("&lt;h2 style='color:red'&gt;正文测试2&lt;/h2&gt;", true); mimeMessageHelper.addAttachment("1.jpg", new File("D:\\用户目录\\我的图片\\02_CONVERSEXMDNS_LANDINGPAGE_20181007_01.jpg")); //设置发件人 mimeMessageHelper.setFrom("xxxxxxxxx@qq.com"); //设置收件人 mimeMessageHelper.setTo("xxxxxxxxx@gmail.com"); javaMailSender.send(mimeMessage); &#125;&#125; 2.4 运行接收方邮箱便能收到邮件，且邮件带有一份名为1.jpg的附件。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot异步任务和定时任务]]></title>
    <url>%2F2019%2F04%2F17%2FSpring-Boot%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 异步任务1.1 简介项目开发中，绝大多数情况是通过同步方式处理业务逻辑，但批量处理数据，批量发送邮件等容易造成阻塞，之前都是通过使用多线程来完成此类任务。 在Spring 3+后内置了@Async注解来解决此类问题，提高效率。 1.2 启动类上使用@EnableAsync注解在启动类上使用@EnableAsync注解，开启基于注解版的异步处理。 代码示例： 123456789@EnableAsync //开启基于注解版的异步处理@SpringBootApplicationpublic class SpringBoot11TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot11TaskApplication.class, args); &#125;&#125; 1.3 在方法上使用@Async注解在方法上标识@Async注解，该方法就会基于异步处理。 代码示例： 1234567891011121314@Servicepublic class AsyncService &#123; @Async //在该方法上标识注解，该方法就会基于异步处理 public void batchAdd() &#123; try &#123; //模拟新增数据 Thread.sleep(3*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("批量新增数据完成"); &#125;&#125; 2. 定时任务2.1 简介在项目开发中，经常要执行一些定时任务。 2.2 启动类上使用@EnableScheduling注解在启动类上使用@EnableScheduling注解，开启注解版的定时任务。 代码示例： 123456789@EnableScheduling //开启注解版的定时任务@SpringBootApplicationpublic class SpringBoot11TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot11TaskApplication.class, args); &#125;&#125; 2.3 在方法上使用@Scheduled注解代码示例： 123456789101112131415@Servicepublic class ScheduledService &#123; private static int count = 1; /** * on the second(秒) as well as minute(分), hour(时), day(天) of month, month(月) and day of week(星期). * &lt;p&gt;E.g. &#123;@code "0 * * * * MON-FRI"&#125; means once per minute on weekdays 表示在工作日（周一到周五）每分钟执行一次 */ //cron = "*/3 * * * * MON-FRI"表示在周一到周五每三秒执行一次 @Scheduled(cron = "*/3 * * * * MON-FRI") public void dataCount() &#123; System.out.println("数据统计第" + count++ + "次"); &#125;&#125; 2.3 @Scheduled详解 @Scheduled(cron = &quot;*/3 * * * * MON-FRI&quot;)：通过cron表达式定义规则。 cron表达式自动生成网站： http://cron.qqe2.com/ 从左到右依次 取值范围 可指定的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * / ? L W C 月份 1-12 , - * / 星期 0-7或MON-SUN（0和7都代表周日，1-6代表周一到周六） , - * / ? L C # @Scheduled(fixedRate = 3000):上一次开始执行时间点之后3秒再执行。 @Scheduled(fixedDelay = 3000)：上一次执行完毕时间点之后3秒再执行。 @Scheduled(initialDelay=1000, fixedRate=3000)：第一次延迟1秒后执行，之后按fixedRate的规则每3秒执行一次。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>异步任务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合MyBatis]]></title>
    <url>%2F2019%2F04%2F10%2FSpring-Boot%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[1. Spring Boot整合MyBatis配置文件版1.1 建表使用MySQL数据库，新建一个名为“mybatis”的schema，分别建“bill“、”provider“和”user“表并添加数据。 1.2 application.yml全局配置文件12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 1.3 创建实体类在 com.example.springboot.entities 包下创建Provider实体类和Bill实体类。 Provider类： 为减少篇幅，这里只给出成员变量，有参、无参构造方法，get，set，toString方法均省略。 123456789101112131415161718192021public class Provider &#123; private Integer pid; //供应商编码 private String providerCode; //供应商名称 private String providerName; //联系人 private String people; //联系电话 private String phone; //联系地址 private String address; //传真 private String fax; //描述 private String describe; // 创建时间 private Date createDate; 其余代码省略。。。&#125; Bill类： 为减少篇幅，这里只给出成员变量，有参、无参构造方法，get，set，toString方法均省略。 12345678910111213141516171819202122public class Bill &#123; private Integer bid; // 账单编码 private String billCode; // 商品名称 private String billName; // 商品单位 private String billCom; // 商品数量 private Integer billNum; // 总金额 private Double money; // 供应商 private Provider provider; // 是否付款 0 未付款， 1已付款 private Integer pay; // 创建时间 private Date createDate; 其余代码省略。。。&#125; 1.4 创建Mapper接口在 com.example.springboot.mapper 包下创建 BillMapper 接口： 可在各Mapper接口上使用@Mapper注解，表明这是一个Mapper接口。 也可在启动类上直接使用注解@MapperScan(&quot;com.example.springboot.mapper&quot;)，便能扫描该包下的所有Mapper自动装到容器当中，而不用在各Mapper上加上注解@Mapper。 代码示例： BillMapper接口： 12345678910111213141516/** * 使用MyBatis配置文件版 *///@Mapper 或者在启动类上使用注解 @MapperScan("com.example.springboot.mapper")public interface BillMapper &#123; //接口方法默认被public修饰 Bill getBillByBid(Integer bid); int addBill(Bill bill); int updateBill(Bill bill); int deleteBill(Integer bid);&#125; 启动类： 12345678910@MapperScan("com.example.springboot.mapper")//扫描该包下的所有Mapper自动装到容器当中，而不用在各Mapper上加上注解@Mapper@SpringBootApplicationpublic class SpringBoot08DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataMybatisApplication.class, args); &#125;&#125; 1.5 创建MyBatis核心配置文件在resources目录下新建mybatis目录，在该目录下创建mybatis-config.xml，这便是MyBatis核心配置文件，我在这仅仅配置了开启自动驼峰命名规则映射，文件编写参考官方文档：http://www.mybatis.org/mybatis-3/zh/getting-started.html 代码示例： 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 这是mybatis核心配置文件 --&gt; &lt;settings&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射， 即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 1.6 创建Mapper映射配置文件在resources目录的mybatis目录下新建mapper目录，在该目录下创建BillMapper.xml，在此文件中编写sql语句，文件编写也参考官网文档：http://www.mybatis.org/mybatis-3/zh/getting-started.html 代码示例： 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.springboot.mapper.BillMapper"&gt; &lt;select id="getBillByBid" resultType="com.example.springboot.entities.Bill"&gt; select * from bill where bid = #&#123;bid&#125; &lt;/select&gt; &lt;insert id="addBill"&gt; insert into bill(bill_code, bill_name, bill_com, bill_num) values (#&#123;billCode&#125;, #&#123;billName&#125;, #&#123;billCom&#125;, #&#123;billNum&#125;) &lt;/insert&gt;&lt;/mapper&gt; &lt;mapper namespace=&quot;com.example.springboot.mapper.BillMapper&quot;&gt;定义了对应接口BillMapper的路径。 以查询为例，select id=&quot;getBillByBid&quot;，getBillByBid与接口中的方法Bill getBillByBid(Integer bid);对应，resultType=&quot;com.example.springboot.entities.Bill&quot;则是方法返回值的实体类Bill的路径。 #{}用于表示一个占位符，相当于?，而#{bid}则表示该占位符待接收参数的名称为bid。 1.7 重新配置application.yml全局配置文件1234567891011121314151617181920212223242526272829303132333435spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# mybatis配置文件版，配置相关文件路径mybatis: # 映射文件路径 mapper-locations: classpath:mybatis/mapper/*.xml # mybatis核心配置文件路径 config-location: classpath:mybatis/mybatis-config.xml classpath:表示类路径，在Spring Boot项目里等同于resources目录，在其他项目也可等同于res目录。 *.xml表示该目录下所有.xml文件。 1.8 创建控制层在com.example.springboot.controller包下新建类BillController： 123456789101112131415161718@RestControllerpublic class BillController &#123; @Autowired BillMapper billMapper; @GetMapping("/bill/&#123;bid&#125;") public Bill getBillByBid(@PathVariable("bid") Integer bid) &#123; Bill bill = billMapper.getBillByBid(bid); return bill; &#125; @GetMapping("/bill") public Bill addBill(Bill bill) &#123; int i = billMapper.addBill(bill); return bill; &#125;&#125; @RestController注解等同于@Controller+@ResponseBody这两个注解合在一起的作用，表示不返回jsp或html页面，直接返回return的内容。 @Autowired BillMapper billMapper; 表示直接将BillMapper接口注入。 1.9 测试启动启动类SpringBoot08DataMybatisApplication，在浏览器输入：http://localhost:8080/bill/1 效果显示： 数据库中bill表： 网页中数据与数据库中均一一对应，表明成功。 2. Spring Boot整合MyBatis注解版2.1 建表同1.1，表已经建好。 2.2 application.yml全局配置文件12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 2.3 创建实体类同1.3，实体类均已创建好。 2.4 创建Mapper接口在 com.example.springboot.mapper 包下创建 ProviderMapper 接口。 代码示例： ProviderMapper接口： 123456789101112131415161718192021222324/** * 使用mybatis注解版 */@Mapper //这是指定操作数据的Mapperpublic interface ProviderMapper &#123; //接口默认public修饰 //查 @Select("select * from provider where pid = #&#123;pid&#125;") Provider getProviderByPid(Integer pid); //增 @Insert("insert into provider(providerName) values (#&#123;providerName&#125;)") int addProvider(Provider provider); //删 @Delete("delete from provider where pid = #&#123;pid&#125;") int deleteProviderByPid(Integer pid); //改 @Update("update provider set providerName = #&#123;providerName&#125;") int updateProvider(Provider provider);&#125; 启动类： 12345678@SpringBootApplicationpublic class SpringBoot08DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataMybatisApplication.class, args); &#125;&#125; 2.5 创建控制层在 com.example.springboot.controller 包下创建ProviderController类。 代码示例： 123456789101112@RestControllerpublic class ProviderController &#123; @Autowired ProviderMapper providerMapper; @GetMapping("/provider/&#123;pid&#125;") public Provider getProvider(@PathVariable("pid") Integer pid) &#123; Provider provider = providerMapper.getProviderByPid(pid); return provider; &#125;&#125; 2.6 创建MyBatis配置类因为MyBatis注解版没有xml配置文件，所以需要使用配置类来配置，我在 com.example.springboot.config 包下创建MyBatisConfig类，主要配置了开启了自动驼峰命名规则映射。 代码示例： 12345678910111213141516@Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer ConfigurationCustomizer() &#123; ConfigurationCustomizer configurationCustomizer = new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; //是否开启自动驼峰命名规则（camel case）映射， // 即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; return configurationCustomizer; &#125;&#125; 2.7 测试启动启动类SpringBoot08DataMybatisApplication，在浏览器输入：http://localhost:8080/provider/1 网页效果： 数据表： 测试成功。 3. 心得无论Mybatis注解版还是配置文件版，都能实现相同功能，所以都需要掌握。 但是本人更倾向于配置文件版，因为如果遇到复杂的sql语句，写在注解上让代码显得特别繁琐复杂，而单独写在mapper映射文件中则显得简洁许多。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>MySQL</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot事务管理]]></title>
    <url>%2F2019%2F04%2F09%2FSpring-Boot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 事务管理1.1 简介事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。在Spring Boot中，使用了spring-boot-starter-jdbc或者spring-boot-starter-data-jpa依赖时，框架会自动默认注入DataSourceTransactionManager或者jpaTransactionManager。所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。 1.2 事务管理步骤 在启动类中，使用@EnableTransactionManagement开启注解方式事务管理支持。 123456789@EnableTransactionManagement //开启注解方式事务支持@SpringBootApplicationpublic class SpringBoot08DataJpaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataJpaApplication.class, args); &#125;&#125; 在Service层方法上使用@Transactional注解。 @Transactional也可直接注解在类上，这样默认该类下所有方法都开启事务注解。 但实际中一般只对 增、删、改 进行事务管理，不对 查 进行事务管理，所以注解在方法上。 1.3 注意 application.yml配置文件 1234567891011121314spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/jpa?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关配置 jpa: hibernate: # 会根据映射实体类自动创建会更新数据表 ddl-auto: update # 控制台打印sql语句 show-sql: true 如果使用 JPA（Java Persistence API），hibernate在自动创建表时，创建的表引擎是 MyISAM，是非事务安全的，无法实现事务回滚。需要指定 InnoDB 引擎才可以进行事务管理。 在application.yml配置文件中添加配置 12345678910111213141516spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/jpa?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关配置 jpa: hibernate: # 会根据映射实体类自动创建会更新数据表 ddl-auto: update # 控制台打印sql语句 show-sql: true # 指定表的引擎为InnoDB，如果不指定，则默认表引擎为MyISAM,MyISAM是不支持事务管理的 database-platform: org.hibernate.dialect.MySQL57Dialect 2. 事务的隔离级别2.1 脏读、不可重复读和幻读 脏读：A事务执行过程中修改了id=1的数据，未提交前，B事务读取了A事务修改的id=1的数据，而这时A事务却回滚了，这样B事务就形成了脏读。 不可重复读：A事务先读取了一条数据，然后执行逻辑，这时B事务将这条数据改变了，然后A事务再次读取这条数据，发现数据不匹配了，这就是不可重复读。 幻读：A事务先根据条件查询到了N调数据，然后这时B事务新增了M条符合A事务查询条件的数据，A事务再次查询时发现有N+M条数据了，就产生了幻读。 2.2 隔离级别数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。 隔离级别 脏读 不可重复读 幻读 Read uncommitted（读未提交） √ √ √ Read committed（读提交） × √ √ Repeatable read（重复读） × × √ Serializable（序列化） × × × 2.3 源码查看org.springframework.transaction.annotation包中的枚举类Isolation定义了五个表示隔离级别的值： 12345678910111213141516171819package org.springframework.transaction.annotation;public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8); private final int value; private Isolation(int value) &#123; this.value = value; &#125; public int value() &#123; return this.value; &#125;&#125; DEFAULT：默认值，表示使用底层数据库的默认隔离级别，大多数数据库的默认隔离级别是READ_COMMITTED。 READ_UNCOMMITTED：通常很少使用该隔离级别，因为避免不了脏读、不可重复读和幻读。 READ_COMMITTED：可以防止脏读，也是大多数数据库的默认隔离级别，比如SQL Server , Oracle，性能最好。 REPEATABLE_READ：可以避免脏读和不可重复读，是MySQL的默认隔离级别。 SERIALIZABLE：可以避免脏读、不可重复读和幻读，但严重影响程序性能，通常不会用到该级别。 2.4 指定隔离级别在@Transactional注解上设置属性： 123@Transactional(isolation = Isolation.DEFAULT) //当前方法开启事务管理 //isolation指定隔离级别，当前指定为默认 3. 事务的传播行为3.1 源码查看org.springframework.transaction.annotation包中的枚举类Propagation定义了七个表示传播行为的值： 123456789101112131415161718192021package org.springframework.transaction.annotation;public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6); private final int value; private Propagation(int value) &#123; this.value = value; &#125; public int value() &#123; return this.value; &#125;&#125; REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。如果A方法有事务，那么B方法就使用A方法的事务。如果A方法没有事务，那么B方法就创建一个新事物。是Spring提供的默认事务传播行为，适合绝大数情况。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。如果A方法有事务，那么B方法就使用A方法的事务。如果A方法没有事务，那么B方法就不使用事务的方式执行 MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。如果A方法有事务，那么A方法就使用A方法事务。如果A方法没有事务，那么就抛出异常。该事务传播行为要求A方法必须以事务的方式运行。 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。如果A方法有事务，就把A方法的事务挂起，B方法新创建一个事务。如果A方法没有事务，那么B方法就创建一个新事务。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。如果A方法有事务，那么就把A方法的事务挂起，B方法以非事务的方式执行。如果A方法没有事务，那么B也不使用事务执行。 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。如果方法A有事务，那么就抛出异常。如果方法A没有事务，那么B方法就以非事务的方式运行。 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的。如果A方法有事务，那么B方法就在A方法的事务中使用嵌套事务。如果A方法没有事务，那么方法B就新创建一个事务。 3.2 指定传播行为在@Transactional注解上设置属性： 1234@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED )//当前方法开启事务管理//isolation指定隔离级别，当前指定为默认//propagation指定传播行为，当前指定为默认]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Druid数据库连接池]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%85%8D%E7%BD%AEDruid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[1. 配置Druid数据库连接池什么是数据库连接池？ 参考：https://www.cnblogs.com/aspirant/p/6747238.html Spring Boot 2.0 默认使用 HikariCP 作为数据库连接池。 Druid 是阿里巴巴推出的国产数据库连接池，据网上测试对比，比目前的 DBCP 或 C3P0 数据库连接池性能更好，并且 Druid 能够提供强大的监控和扩展功能。 1.1 在pom.xml中引入依赖123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt; 1.2 在全局配置文件application.yml中配置12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/jdbc?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 1.3 绑定Druid相关信息在config目录下新建类DruidConfig 123456789@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid() &#123; return new DruidDataSource(); &#125;&#125; 至此Druid数据库连接池配置完毕。 2. 配置Druid的监控Druid 自带监控管理系统，要配置一个Druid监控： 配置一个Druid的Servlet 配置一个Druid的Filter 完成 2.1 配置一个Druid的Servlet在config目录下DruidConfig类下: 1234567891011121314151617//配置一个Druid的后台管理系统的Servlet@Beanpublic ServletRegistrationBean statViewServlet() &#123; //请求是/druid/* ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), "/druid/*"); //设置初始化参数值 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(StatViewServlet.PARAM_NAME_USERNAME, "root"); map.put(StatViewServlet.PARAM_NAME_PASSWORD, "123456"); //如果不写，则默认所有IP地址都可以访问 map.put(StatViewServlet.PARAM_NAME_ALLOW, ""); //指定IP地址禁止访问 map.put(StatViewServlet.PARAM_NAME_DENY, "192.168.1.1"); bean.setInitParameters(map); return bean;&#125; 2.2 配置一个Druid的Filter在config目录下DruidConfig类下: 123456789101112131415//配置一个Druid的Filter@Beanpublic FilterRegistrationBean webStatFilter() &#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); //设置不拦截的请求 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, "*.js, *.css, /druid/*"); bean.setInitParameters(map); //设置拦截请求, /* 表示拦截所有请求 bean.setUrlPatterns(Arrays.asList("/*")); return bean;&#125;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot嵌入式Servlet容器]]></title>
    <url>%2F2019%2F04%2F03%2FSpring-Boot%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 修改Servlet配置参考pom.xml文件可以知道，Spring Boot默认使用Tomcat作为嵌入式的Servlet容器。 1.1 通过全局配置文件修改Servlet配置通过修改全局配置文件application.properties，修改嵌入式Servlet容器配置： 12345678910# 修改关于服务的相关配置，对应的类是ServerProperties# 修改端口号server.port=8081# 修改Servlet的相关配置，修改应用名server.servlet.context-path=/servlet# 修改Tomcat的相关配置server.tomcat.max-connections=80000 1.2 通过自定义配置器修改Servlet配置Spring Boot 2.x： 实现WebServerFactoryCustomizer接口的customize抽象方法： 123456789101112131415161718/** * 自定义定制器修改Servlet容器配置 */@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; //采用匿名内部类实现WebServerFactoryCustomizer接口的void customize(T factory)抽象方法 return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; ConfigurableServletWebServerFactory factory1 = (ConfigurableServletWebServerFactory) factory; //修改端口号，如果全局配置文件中的配置与定制器的配置冲突，默认采用定制器的配置 factory1.setPort(8082); //修改应用名 factory1.setContextPath("/servlet2"); &#125; &#125;;&#125; 2. 切换为其他嵌入式Servlet容器Spring Boot默认针对Servlet容器提供以下支持： Tomcat（默认使用）。 Jetty：支持长连接项目（如：聊天页面）。 Undertow：不支持jsp，但是并发性能高，是高性能非阻塞的容器。 2.1 使用Jetty 在pom.xml文件中移除Tomcat 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 移除Tomcat启动器 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入Jetty依赖 12345&lt;!-- 引入Jetty启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 使用Undertow 在pom,xml文件中移除Tomcat，代码同上。 引入Undertow依赖 12345&lt;!-- 引入Undertow启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中pom文件的依赖配置]]></title>
    <url>%2F2019%2F04%2F02%2FSpring-Boot%E4%B8%ADpom%E6%96%87%E4%BB%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. pom.xml文件中依赖配置Spring Boot中需要使用什么，只需在pom.xml文件中引入相对应的依赖即可，以下来介绍各种依赖。 1.1 thymeleaf模板启动器12345&lt;!-- 引入thymeleaf模板启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 注释处理器123456&lt;!-- 该依赖为注释处理器，在编写配置文件时能自动提示自定义的类 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 1.3 热部署12345&lt;!-- 热部署依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 1.4 jquery webjars123456&lt;!-- 引入jquery webjars --&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-2&lt;/version&gt;&lt;/dependency&gt; 1.5 Druid数据库连接池1234567&lt;!-- Druid数据库连接池 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt; 1.6 MyBatis123456&lt;!-- MyBatis启动器，已经引入了spring-boot-starter-jdbc启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 1.7 JDBC1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 1.8 Java连接MySQL驱动包123456&lt;!-- Java连接MySQL驱动包 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot实现热部署]]></title>
    <url>%2F2019%2F04%2F02%2FSpring-Boot%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[1. Spring Boot实现项目的热部署1.1 简介Spring Boot项目的热部署，按照我的理解，就是在修改代码后，无须重新启动服务器，只需要重新Build Project，然后刷新网页，就可以立即在网页查看到修改后的变化。 1.2 在配置文件中禁用模板缓存如果不禁用缓存，那么因为有网页的缓存，变化无法实时获取，所以在配置文件application.properties或者application,yml中禁用Thymeleaf模板缓存，下面以application.properties配置文件为例： 12# 开发中推荐关闭thymeleaf的缓存，可以实现热部署spring.thymeleaf.cache=false 1.3 在pom.xml文件中引入依赖在pom.xml文件中引入热部署依赖： 12345&lt;!-- 热部署依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 1.4 实现按IDEA快捷键 ctrl+F9 进行Build Project，无须重新启动服务器，然后刷新网页即可实现项目的热部署。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Thymeleaf（二）]]></title>
    <url>%2F2019%2F03%2F31%2FSpring-Boot%E6%95%B4%E5%90%88Thymeleaf%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 声明公共代码片段1.1 简介有两种方式声明公共代码片段： 通过th:fragment声明公共代码片段。 通过id选择器声明公共代码片段。 1.2 通过th:fragment声明示例： 123456&lt;!-- 通过th:fragment声明公共代码片段 --&gt;&lt;div th:fragment="header_common"&gt; &lt;p&gt; 文字内容 &lt;/p&gt;&lt;/div&gt; 1.3 通过id选择器声明示例： 123456&lt;!-- 通过id选择器进行声明公共代码片段 --&gt;&lt;div id="header_common_id"&gt; &lt;p&gt; 文字内容 &lt;/p&gt;&lt;/div&gt; 2. 引入公共代码片段2.1 简介有两种方式引入申明过的公共代码片段： 通过th:replace引入：不保留引入公共代码片段时当前所使用的标签，即用引入的标签 替换 当前标签。 通过th:insert引入：保留引入公共代码片段时当前所使用的标签，即将公共代码块 插入 当前标签，变成当前标签的子标签。 2.2 通过th:replace引入2.2.1 引入通过th:fragment声明的公共代码片段示例： 1234&lt;!-- 通过th:replace引入通过th:fragment声明公共代码片段 注意header是文件名，header_common就是声明的属性值--&gt;&lt;div th:replace="header :: header_common"&gt;&lt;/div&gt; 2.2.2 引入通过id选择器声明的公共代码片段示例： 1234&lt;!-- 通过th:replace引入通过id选择器进行声明公共代码片段 注意header是文件名，#header_common_id就是声明的id值--&gt;&lt;div th:replace="header :: #header_common_id"&gt;&lt;/div&gt; 2.3 通过th:insert引入2.3.1 引入通过th:fragment声明的公共代码片段示例： 1&lt;h2 th:insert="header :: #header_common"&gt;&lt;/h2&gt; 2.3.2 引入通过id选择器声明的公共代码片段示例： 1&lt;h2 th:insert="header :: #header_common_id"&gt;&lt;/h2&gt;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Thymeleaf（一）]]></title>
    <url>%2F2019%2F03%2F24%2FSpring-Boot%E6%95%B4%E5%90%88Thymeleaf%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 迭代集合数据1.1 简介 使用th:each进行迭代，th:each作用在哪个标签上，就会对应的根据他的值迭代多少次。 th:each后可取两个值： use：第一个值，代表每次迭代出的对象，名字任意取。 iterStat：第二个值，代表每次迭代器的内置对象，名字任意取，并有以下属性： index：当前迭代下标从0开始。 count：当前迭代下标从1开始。 size：获取总记录数。 current：获取当前迭代的对象。 even/odd：当前迭代是否为偶数/奇数（从1开始算，返回值为布尔值）。 first：当前是否为第一个元素。 last：当前是否为最后一个元素。 1.2 迭代在当前标签的子标签上示例： 1234567&lt;tr th:each="user, iterStat : $&#123;userList&#125;"&gt; &lt;td th:text="$&#123;user.username&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.count&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.gender == 1 ? '男' : '女'&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.current&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.even ? '偶数' : '奇数'&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; 1.3 迭代在当前标签上示例： 123&lt;ul&gt; &lt;li th:each="user : $&#123;userList&#125;" th:text="$&#123;user.username&#125;"&gt;&lt;/li&gt;&lt;/ul&gt; 2. 条件判断2.1 简介 通常使用th:if和th:unless进行条件判断。 使用th:if，如果th:if为true，则显示标签的内容，否则不显示。 使用th:unless，如果th:unless为false，则显示标签内容，否则不显示。 th:if判断特殊表达式： 如果值为null，则返回false。 如果值不为null，以下情况均为true： 如果值是Boolean型且值为true。 如果值是数值型且值不为0。 如果值是字符型型且值不为空。 如果值是字符串型且值不为”false”,”off”或者”no”。 如果值不是以上的类型。那么也为true。 th:unless和th:if相反，我将”if”翻译成”如果”，将”unless”翻译成”如果不”。 2.2 th:if用法示例：假设以下代码userList不为空 1&lt;h3 th:if="not $&#123;#lists.isEmpty(userList)&#125;"&gt;显示内容&lt;/h3&gt; 结果：在网页上显示“显示内容”这四个字。 分析：${&#35;lists.isEmpty(userList)}返回值为false，则not ${&#35;lists.isEmpty(userList)}返回值为true，故显示标签内容。 2.3 th:unless用法实例：假设以下代码userList不为空 1&lt;h3 th:unless="$&#123;#lists.isEmpty(userList)&#125;"&gt;显示内容&lt;/h3&gt; 结果：在网页上显示“显示内容”这四个字。 分析：${&#35;lists.isEmpty(userList)}返回值为false，故显示标签内容。 未完待续~~]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Spring Boot配置文件简介]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%85%B3%E4%BA%8ESpring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. YAML语言1.1 简介YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，文件名以.yml结尾。 1.2 基本语法 key: value表示一对键值对（冒号后面必须要有一个空格）。 key和value大小写敏感。 使用空格缩进，不允许使用Tab键缩进，缩进表示层级关系，缩进的空格数量无要求（一般空两格），但同一层级要对齐。 使用#进行注释，从这个字符一直到行尾都会被解析器忽略。 1.3 示例1234567#emp的数据配置emp: lastName: Tom age: 22 salary: 10000 boss: true birthday: 1997/08/20 2. Spring Boot配置文件2.1 全局配置文件 可以使用.properties文件配置，命名为application.properties。 也可以使用.yml文件配置，命名为application.yml。 2.2 注解2.2.1 @ConfigurationProperties表示默认从全局配置文件application.properties或者application.yml中获取值，告诉Spring Boot将配置文件中的对应的属性值映射到这个组件类中，进行一一绑定。 全局配置文件application.yml： 123456789101112131415161718#emp的数据配置emp: lastName: Tom age: 22 salary: 10000 boss: true birthday: 1997/08/20 map: key1: value1 key2: value2 key3: value3 list: - one - two - three forte: name: java time: 8 实体类Emp.java： 123456789101112/*** * @ConfigurationProperties 加载全局配置文件，告诉SpringBoot将配置文件中的对应属性值， * 映射到这个组件类中，进行一一绑定 * prefix = "emp" 代表与配置文件中的前缀名绑定 ，配置了哪个前缀就会将配置文件的配置与下面的属性一一映射 * @Component 必须将当前组件作为SpringBoot中的一个组件来使用，这样才会纳入容器中管理 */@Component@ConfigurationProperties(prefix = "emp")public class Emp &#123; //定义成员变量、Getter和Setter方法以及toString方法的代码块&#125; 2.2.2 @Value在某个业务逻辑中需要获取配置文件中的某个属性值。 全局配置文件application.properties： 123456789101112#配置emp的数据emp.last-name=李四emp.age=30emp.salary=20000emp.birthday=1998/08/30emp.boss=falseemp.map.key1=value1emp.map.key2=value2emp.map.key3=value3emp.list=one, two, threeemp.forte.name=pythonemp.forte.time=5 控制层empController.java： 12345678910111213141516171819202122@Controllerpublic class empController &#123; /** * @Value好比Spring框架中使用配置文件的数据注入方式 * &lt;bean class="Emp"&gt; * &lt;property name="lastName" value="字面量"或者 * value=#&#123;spEL&#125;或者 * value=$&#123;key&#125;&gt;&lt;/property&gt; * &lt;/bean&gt; * #&#123;spEL&#125;即为Spring表达式，比如#&#123;3*10&#125; * $&#123;key&#125;用来引用配置文件中的数据 */ @Value("$&#123;emp.last-name&#125;") String name; @ResponseBody @RequestMapping("/say") public String sayHello() &#123; return "Hello " + name; &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
</search>
