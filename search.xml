<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于Java多态与继承一些注意]]></title>
    <url>%2F2019%2F10%2F16%2F%E5%85%B3%E4%BA%8EJava%E5%A4%9A%E6%80%81%E4%B8%8E%E7%BB%A7%E6%89%BF%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%2F</url>
    <content type="text"><![CDATA[例如：A类： 12345678public class A &#123; public void show(A a) &#123; System.out.println(1111); &#125; public void show(C c) &#123; System.out.println(3333); &#125;&#125; B类： 1234567891011121314public class B extends A &#123; @Override public void show(A a) &#123; System.out.println(2222); &#125; public void show(B b) &#123; System.out.println(4444); &#125; public void show1() &#123; System.out.println(5555); &#125;&#125; C类： 12public class C extends B &#123;&#125; 测试类： 1234567891011public class Main &#123; public static void main(String[] args) &#123; A a = new B(); B b = new B(); C c = new C(); a.show(a); a.show(b); a.show(c); &#125;&#125; 结果为： 123222222223333 解释：为什么结果会这样呢？ 首先A a = new B()，a为引用，类型为父类A类，但它指向子类B类的对象实例，所以a只能调用在A类定义过的方法，而不能调用在B类中新增的方法，如果A类中的某个方法在B类中被重写，那么调用重写的那个方法。还有一个是Java类型匹配，如果类型不能匹配就自动向上转型转为父类（就近原则，转换到能匹配到为止，就不再继续向上转型）。 接下来就可以解释通了： a.show(a); 传参a实际是B类，但是a引用类型为A类，只能调用A类的方法，传参a自动向上转型为A类，便有A类中的public void show(A a) {System.out.println(1111);}方法，但是此方法在B类中被重写，所以调用B类重写的@Override public void show(A a) {System.out.println(2222);}方法，所以控制台打印”2222”。 a.show(b); 同上，传参b实际是B类，但是a引用类型为A类，只能调用A类的方法，传参a自动向上转型为A类，便有A类中的public void show(A a) {System.out.println(1111);}方法，但是此方法在B类中被重写，所以调用B类重写的@Override public void show(A a) {System.out.println(2222);}方法，所以控制台打印”2222”。 a.show(c); 传参c实际类型为C，于是直接可以调用A类的public void show(C c) {System.out.println(3333);}方法，于是控制台打印”3333”。 如果在测试类中再添加一句a.show1();会怎样，结果是编译通不过，因为a的引用类型为A 类，所以只能调用A类中定义的方法，A类没有show1()这个方法，于是无法调用，编译通不过。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Integer的一些问题]]></title>
    <url>%2F2019%2F10%2F15%2F%E5%85%B3%E4%BA%8EInteger%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1. IntegerInteger是包装类，对应基本数据类型为int。 2. 自动装箱与自动拆箱2.1 自动装箱1234int i1 = 100;Integer i2 = 100;Integer i3 = Integer.valueOf(100);Integer i4 = new Integer(100)； 疑问是： 像第一行i1是基本数据类型int所以可以直接赋值，那么第二行i2是Integer类对象的引用，怎么也能直接赋值呢？ 其实这就是自动装箱，以上二、三两行代码实质意义相同，将第二行代码编译成class文件再反编译，其实就是第3行代码这种写法，而第三行的写法其实就是在堆内存上新建一个Integer对象，i3为这个对象的引用。 而第四行的就是我们正常用构造方法创建一个Integer对象，每用这个方法创建一个Integer对象，都会在堆内存新建一个对象。 缓存机制： Integer包装类还有一个缓存机制，可以查看源码： 123456789101112131415161718192021222324252627282930313233343536373839private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125; &#125;public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i); &#125; 示例： 123456789@Test public void test() &#123; Integer i1 = 1; Integer i2 = 1; Integer i3 = 1000; Integer i4 = 1000; System.out.println(i1 == i2); System.out.println(i3 == i4); &#125; 结果为： 12truefalse “==”比较的是两个引用的内存地址是否相同，因为1在[-128, 127]之间，所以Integer i1 = 1;在堆内存上新建了一个Integer对象并缓存，i2同样指向这个Integer对象，所以i1和i2指向同一个内存地址，所以结果为true； 而1000不在[-128, 127]之间，Integer i3 = 1000;在堆内存上新建了一个Integer对象，Integer i4 = 1000; 在堆内存上又新建了一个Integer对象，所以i3和i4指向不同内存地址，所以结果为false。 2.2 自动拆箱自动拆箱即将Integer类型的对象自动拆箱为int基本数据类型，以下情况会自动拆箱： 包装类和基本数据类型的相等判断： 123456@Test public void test() &#123; Integer i1 = 1; int i2 = 1; System.out.println(i1 == i2); &#125; 以上代码编译再反编译其实就是： 123456@Test public void test() &#123; Integer i1 = 1; int i2 = 1; System.out.println(i1.intValue() + i2); &#125; 自动拆箱也就是调用了i1.intValue()方法。 包装类和基本数据类型的四则运算： 123456@Test public void test() &#123; Integer i1 = 1; int i2 = 1; System.out.println(i1 + i2); &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议]]></title>
    <url>%2F2019%2F07%2F22%2FHTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[1. HTTP协议HTTP协议（Hyper Text Transfer Protocol，超文本传输协议）是TCP/IP模型中应用层协议，提供了客户端和服务端之间传输信息的机制。特点： 支持C/S模式。 无连接。 无状态。 默认端口号80。 HTTP有两类报文： 请求报文（在Java的Servlet中被封装成HttpRequest类） 响应报文（在Java的Servlet中被封装成HttpResponse类） 1.1 请求报文结构： 请求行（Request Line）：方法（GET、POST等）、URL、版本（HTTP协议的版本）。 首部行（Header Line ）：包括要请求的服务器主机域名信息、产生请求的客户端信息、客户端可以识别的数据类型信息等。 正文：一般为空，GET请求会将参数放在URL中，POST请求将参数放在实体主体中。 1.2 相应报文结构： 状态行（Status Line）：服务器HTTP协议版本、状态码（1xx、2xx、3xx、4xx、5xx）、状态码文本描述（比如200对应OK）。 首部行（Header Line）：包括生成响应的日期、服务器版本、编码格式等信息。 响应正文：服务器返回的响应正文信息。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的Collection]]></title>
    <url>%2F2019%2F07%2F22%2FJava%E4%B8%AD%E7%9A%84Collection%2F</url>
    <content type="text"><![CDATA[1. Java中的CollectionCollection是List接口、Set接口、Queue接口的父接口。 继承关系如下： 2. List接口List有序、可重复。可以用Iterator实现单向遍历，也可以用ListIterator实现双向遍历。 List接口的实现类： ArrayList LinkedList Vector Stack等 2.1 ArrayList 底层数据结构是数组，查询快增删慢（因为数组在内存中空间是连续的）。 线程不安全，效率高。 2.2 LinkedList 底层数据结构是链表，查询慢，增删快。 线程不安全，效率高。 2.3 Vector 底层数据结构是数组，查询快，增删慢。 线程安全，效率低。 2.4 Stack 继承了Vector类。 遵循后进先出的原则。 提供了push（入栈）、pop（出栈）等方法。 2. Set接口Set无序、不可重复。只能用用Iterator实现单向遍历。最多包含一个null元素。 Set的实现类： HashSet TreeSet等 2.1 HashSet 无序，底层用HashMap实现。 非线程同步。 2.2 TreeSet 因为TreeSet实现的是SortedSet接口（SortedSet继承Set接口），且底层数据接口是红黑树，所以是有序的。 3. Queue接口Queue遵循先进先出的原则。通常不允许null元素。 Queue实现类： LinkedList等 3.1 LinkedList 既实现List接口又实现Queue接口。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet和Servlet容器]]></title>
    <url>%2F2019%2F07%2F21%2FServlet%E5%92%8CServlet%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Minor GC、Major GC和Full GC]]></title>
    <url>%2F2019%2F07%2F20%2FMinor-GC%E3%80%81Major-GC%E5%92%8CFull-GC%2F</url>
    <content type="text"><![CDATA[1. Minor GCMinor GC（次要垃圾回收）：对年轻代的垃圾回收。 Eden空间被填满时触发一次Minor GC。存活的对象被复制到Survivor to空间中，Eden空间和Survivor from空间的对象被清空。对象每经过一次GC还存活，年龄计数器加一，超过特定值还存活，将被送入老年代。 2. Major GCMajor GC（主要垃圾回收）：对老年代的垃圾回收。老年代生活的对象一般是大对象（字符串、数组等），还有就是年龄超过特定值从年轻代过来的对象。 3. Full GCFull GC（全部垃圾回收）：对整个堆以及方法区（这个我个人推断的，可能是）的垃圾回收。 4. 总结Minor GC速度快，Major GC和Full GC速度慢。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中变量存在JVM内存的哪一块？]]></title>
    <url>%2F2019%2F07%2F20%2FJava%E4%B8%AD%E5%8F%98%E9%87%8F%E5%AD%98%E5%9C%A8JVM%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%80%E5%9D%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[1. 关于JVM内存布局请参考： https://fuyuanyua.github.io/2019/07/19/%E6%B5%85%E8%B0%88JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8CGC/ 2. 对象实例与对象引用1Student student = new Student(); 关注以上代码： new Student()是对象实例。 student是对象引用，指向对象实例的内存地址。 3. 变量变量分为成员变量和局部变量。 3.1 成员变量12int a = 1;Student student1 = new Student(); 成员变量即在类中声明的变量，当变量为成员变量时： 当声明的成员变量是基本数据类型类型(Primitive Type)的变量（如上面代码中的a）：变量名（a）和值（1）都存放在堆中。 当声明的成员变量是引用类型(Reference Type)变量（如上面代码的student1）：变量名也就是对象引用（student1）和对象实例（new Student()）都存放在堆中。 ps： 基本数据类型类型(Primitive Type)：boolean，byte、short、int、long，float、double、char。 引用类型(Reference Type)：类、接口和数组。就是对对象实例或者数组的引用。 ps：个人理解，因为成员变量都在对象实例里面，所以因为对象实例是被存放在堆上的，对象实例内部的成员变量自然也都存放在堆上。 3.2 局部变量12int b = 2;Student student2 = new Student(); 局部变量即在方法中声明的变量，当变量为局部变量时： 当声明的局部变量是基本数据类型类型(Primitive Type)的变量（如上面代码中的b）：变量名（b）和值（2）都存放在Java虚拟机栈中。 当声明的成员变量是引用类型(Reference Type)变量（如上面代码的student2）：变量名也就是对象引用（student2）存放在Java虚拟机栈中，对象实例（new Student()）存放在堆中。 ps：因为局部变量是存在于方法里的，方法是基于JVM内存中Java虚拟机栈的栈帧（一个方法对应一个栈帧，局部变量和对象引用便存放于栈帧的局部变量表里）实现的：方法开始，栈帧入栈，当方法结束，栈帧便出栈。 以上内容可能会有疏漏与错误，随着我以后的学习会持续更新改正。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈常量池]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[1. 常量在Java中，常量就是被final关键字修饰的变量（final可以修饰成员变量也可以修饰局部变量），值给定后就无法修改。 2. class文件（字节码文件）我们直接编写的.java源文件是无法被JVM识别的，我们需要将.java源文件编译成.class字节码文件，这样才能被JVM识别。 class文件结构： 123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; magic：魔数，占4字节，值固定为0xCAFEBABE，用于标识这是一个class文件。 minor_version：次版本号，占2字节。 major_version：主版本号，占2字节。 constant_pool_count：常量池部分，代表常量池容量。 constant_pool：常量池部分。 其他略。 3. 常量池class文件中常量池主要存放： 字面量（Literal）：如字符串、被final修饰的常量。 符号引用（Symbolic References）： 类和接口的全限定名。 字段名称和描述符。 方法名称和描述符。 4. 运行时常量池class文件中的常量池在类被加载后就被放入方法区的运行时常量池，运行时常量池有动态性，表明常量不一定需要在编译时就产生，运行时也能产生常量放入运行时常量池，比如String类的intern()方法。 以上内容可能会有疏漏与错误，随着我以后的学习会持续更新改正。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈JVM的内存布局和GC]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88JVM%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E5%92%8CGC%2F</url>
    <content type="text"><![CDATA[1. JVM的内存布局JVM即Java Virtual Machine（Java虚拟机）。 JVM中将内存分为若干部分： 堆（Heap） 方法区（Method Area） 栈（Stack） Java虚拟机栈（JVM Stack） 本地方法栈（Native Method Stack） 程序计数器（Program Counter Register） 1.1 堆（Heap）Java堆是被所有线程共享的一块内存区域。 Java堆主要就用来存放数组和类的对象实例，几乎所有对象实例都存放在Java堆，一般情况下，Java堆是JVM内存管理中最大的一块，同时Java堆也是GC（Garbage Collection，垃圾回收）机制执行的主要区域。 Java堆分为年轻代和老年代，而年轻代又被分为三块内存区域：Eden空间、From Survivor空间、To Survivor空间。 堆内存空间不足时抛出outOfMemoryError。 1.2 方法区（Method Area）方法区也是被所有线程共享的一块内存区域。 方法区主要用来存储被虚拟机加载的类的类信息（类名、修饰符等）、字符串和常量、静态变量、编译后的代码等。运行时常量池是方法区的重要部分，class文件中的常量池在类被加载后就被放入方法区的运行时常量池。 方法区也会执行GC，但很少。 方法区内存空间不足时抛出outOfMemoryError。 1.3 Java虚拟机栈（JVM Stack）Java虚拟机栈是线程私有的，它的生命周期与线程相同。 Java虚拟机描述的是Java方法执行的内存模型：每个方法执行时都会同时创建一个栈帧（Stack Frame）用于存储局部变量表（包括基本数据类型和对象引用）、操作数栈、动态链接、方法出口等信息。一个方法从被调用到被执行完成，对应着一个栈帧在Java虚拟机栈中从入栈到出栈的过程。 如果线程请求的栈深度大于虚拟机所允许的深度时，抛出StackOverflowError；当Java虚拟机栈无法申请到足够内存时，抛出OutOfMemoryError。 1.4 本地方法栈（Native Method Stack）本地方法栈是线程私有的，它的生命周期与线程相同。 功能与Java虚拟机栈相同，但本地方法栈为native方法服务。 如果线程请求的栈深度大于虚拟机所允许的深度时，抛出StackOverflowError；当Java虚拟机栈无法申请到足够内存时，抛出OutOfMemoryError。 1.5 程序计数器（Program Counter Register）程序计数器是线程私有的。 程序计数器只占内存的一小块部分。作用是JVM在解释字节码（.class）文件时，作为当前线程正在执行的字节码的行号指示器。每个线程都有一个程序计数器，线程之间的程序计数器相互独立互不干扰。 程序计数器时内存区域是Java虚拟机规范中唯一没有规定OutOfMemoryError的内存区域。 2. GC（Garbage Collection，垃圾回收）随着程序执行，内存中对象实例等占据的内存越来越多，如果不及时回收，程序运行效率就会降低。 在JVM内存布局中， Java虚拟机栈、本地方法栈、程序计数器不需要GC，因为他们生命周期和线程同步，线程销毁，他们占用的内存自动释放；堆、方法区需要GC，主要回收那些没有被引用的对象实例。 2.1 判断Java对象是否存活的算法判断Java对象是否存活的算法： 引用计数器算法 根搜索算法 2.1.1 引用计数器算法给每个对象实例设置一个计数器，当这个对象被引用，计数器 + 1，当这个对象失去引用时，计数器 - 1，当一段时间内这个计数器都为0，则认为这个对象不存活，应当被垃圾回收了。 但是JDK1.1以后，就不采用这种算法了，而是采用根搜索算法。 2.1.2 根搜索算法有一系列的GC Root的根节点，从这些根节点开始往下搜索，搜索通过的路径成为引用链（Reference Chain），当一个对象没有被GCRoot的引用链连接的时候，说明这个对象不可存活，应当被垃圾回收。 可作为GC Root的对象包括： 方法区中常量引用的对象。 方法区中静态属性引用的对象。 Java虚拟机栈中引用的对象。 本地方法栈中引用的对象。 2.2 垃圾回收算法垃圾回收算法主要有： 复制算法 标记-清除算法 标记-压缩算法 2.2.1 复制算法将一块内存空间按1：1比例分为两部分内存1和内存2，只使用内存1，当内存1用满后，将内存1中存活的对象复制到内存2，清空内存1。同理，当内存2用满后，同上操作。 这个算法效率高，不会产生内存碎片，但是会浪费一半内存空间。 ps：堆的年轻代采用的是改进的复制算法，因为年轻代的大多数对象存活时间很短，所以不按1：1的比例分配内存空间，而是将年轻代分为一块较大的Eden空间和两块较小的Survivor空间，比例为8：1：1，每次使用Eden空间和其中一块Survivor空间，当垃圾回收时，将Eden空间和这块Survivor空间中还存活的对象复制到另一块空的Survivor空间，然后将Eden空间和这块Survivor空间清空。 改进后的算法只浪费10%的年轻代内存空间，大大节省了内存空间。 2.2.2 标记-清除算法将所有需要垃圾回收的对象进行标记，标记结束后对被标记的对象进行垃圾回收。 这个算法效率低，会造成大量的内存碎片。 2.2.3 标记-压缩算法将所有需要垃圾回收的对象进行标记，标记结束后对被标记的对象进行垃圾回收，然后把存活的对象向左端内存空间移动。 这个算法和标记-清除算法类似，但多了一个压缩步骤，解决内存碎片的问题。 2.2.4 分代收集算法JVM中，堆的年轻代、老年代和方法区根据各自的特点分别采用了不同的算法。 2.3 垃圾回收器 Serial：单线程的垃圾回收器，垃圾回收时要停止其他所有线程。 Serial Old：Serial用于老年代的版本。 ParNew：Serial的多线程版本。 Parallel Scavenge：用于年轻代的垃圾回收器，基于复制算法，多线程。 Parallel Old：Parallel Scavenge用于老年代的版本。 CMS（Concurrent Mark Sweep）：最大可能解决Serial GC停顿的问题，用于老年代，基于标记-清除算法。 G1：可同时用于年轻代和老年代，基于标记-压缩算法。 以上内容可能会有疏漏与错误，随着我以后的学习会持续更新改正。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈Java中的赋值与拷贝]]></title>
    <url>%2F2019%2F07%2F19%2F%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84%E8%B5%8B%E5%80%BC%E4%B8%8E%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[常见查找算法]]></title>
    <url>%2F2019%2F07%2F18%2F%E5%B8%B8%E8%A7%81%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 顺序查找法顺序查找法很简单，即从到到尾遍历整个数组，直到查找到要查找的数。 2. 二分查找法二分查找法又称折半查找法，是非常常用和高效的查找算法。 2.1 过程 给定一组有序数组int a[] = {0, 12, 24, 36, 48, 60, 72, 84}，要查找的数int target = 24。 设三个变量，start = 0，指向第一个元素a[0]；end = 7，指向最后一个元素a[7]，mid = (start + end) / 2 = 3，指向a[3]。 a[3] = 36，a[3] &gt; 24，所以要查找的数肯定在a[3]以前，所以start = 0不变，end = mid - 1 = 2，指向a[2]，mid = (start + end) / 2 = 1，指向a[1]。 a[1] = 12，a[1] &lt; 24，所以要查找的数肯定在a[1]以后，所以end = 2不变，start = mid + 1 = 2，指向a[2]，mid = (start + end) / 2 = 2，指向a[2]。 a[2] = 24，正是我们要查找的数，查找完毕。（如果我们要查找的数是30，那么24 &lt; 30，所以要查找的数肯定在a[2]以后，所以end = 2不变，start = mid + 1 = 3，此时start &gt; end，那么就表示查找失败了）]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap和HashTable、HashSet的区别]]></title>
    <url>%2F2019%2F07%2F16%2FHashMap%E5%92%8CHashTable%E3%80%81HashSet%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. 三者分别的继承实现关系1.1 HashMap12public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable 1.2 HashTable123public class Hashtable&lt;K,V&gt; extends Dictionary&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, java.io.Serializable 1.3 HashSet123public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable 通过以上可以看出，HashMap和HashTable都是实现了Map接口，是Map接口下的实现类，而HashSet是实现了Set接口，是属于Collection接口下的实现类。 2. HashMap和HashTable的区别 HashTable和HashMap都是存储键值对。 HashTable是线程同步的，HashTable的实现方法里都添加了synchronized关键字来保证线程同步； HashMap缺省是非线程同步的，如果需要则要自己添加同步处理。 HashTable中，key和value都不允许为null； HashMap中，null可以为key，但是唯一，null也可以作为value，可以有多个。判断一个HashMap对象中是否存在某个key，要用containsKey()方法。 HashTable直接使用key的hashCode散列； HashMap获得key的HashCode后要进行二次hash计算然后再散列。 HashTable散列直接通过key的hashCode除以数组length取余； HashMap散列通过key的二次hash和数组length - 1进行与运算。 HashTable初始容量为11，扩容为原容量 * 2 + 1； HashMap初始容量为16，扩容为原容量 * 2。 3. HashSet1234567891011121314151617181920212223public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; implements Set&lt;E&gt;, Cloneable, java.io.Serializable&#123; static final long serialVersionUID = -5024744406713321676L; private transient HashMap&lt;E,Object&gt; map; // Dummy value to associate with an Object in the backing Map private static final Object PRESENT = new Object(); /** * Constructs a new, empty set; the backing &lt;tt&gt;HashMap&lt;/tt&gt; instance has * default initial capacity (16) and load factor (0.75). */ public HashSet() &#123; map = new HashMap&lt;&gt;(); &#125; /** * 其余省略 */&#125; HashMap和HashTable都是存储键值对； HashSet是存储对象。 通过HashSet源码可以知道HashSet是由HashMap对象提供支持的，虽然HashSet实现的是Set接口。HashSet中，元素都存到HashMap键值对的Key上面（HashMap的Key不能重复，所以HashSet的元素也是不能重复的），而Value有一个统一的值private static final Object PRESENT = new Object();(定义一个虚拟的Object对象作为HashMap的value，将此对象定义为static final)。 HashSet的添加删除操作底层都是基于HashMap的添加删除操作。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud简介]]></title>
    <url>%2F2019%2F07%2F10%2FSpring-Cloud%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. 单体应用架构和微服务架构要学习Spring Cloud，我们首先了解单体应用架构和微服务架构。 1.1 单体应用架构传统项目大多数采用了单体应用架构，单个应用包含所有功能，把应用打成一个war或jar包部署到Tomcat中，通常称为单体应用架构。 因为各个功能的页面、代码、配置文件等都在一个项目，使得这个项目十分混乱和复杂。 1.2 微服务架构微服务架构是现在很流行的架构，微服务架构根据项目的业务功能将项目拆分成一个个微服务，一个微服务实现项目中的一个业务功能，每个微服务都独立运行在自己的进程中，服务之间采用轻量级的HTTP通信机制 ( 通常是采用HTTP的RESTful API )进行通信。这些微服务可以用不同的编程语言编写，也可以采用不同的数据库。 因为一个微服务只会关注一个特定的业务功能，所以业务清晰、代码量较少。开发和维护单个微服务相对简单。 2. Spring CloudSpring Cloud是Spring提供的一套基于Spring Boot的微服务架构解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件。 Spring Cloud 使用RESTful API实现微服务之间通信调用。]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC的工作流程]]></title>
    <url>%2F2019%2F06%2F17%2FSpring-MVC%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Spring MVC的工作流程： 用户通过客户端（浏览器）向服务器发送请求（也就是发送URL），请求被DispatcherServlet（前端控制器）拦截。 DispatcherServlet（前端控制器）会调用HandlerMapping（处理器映射器）。 HandlerMapping（处理器映射器）会根据URL找到具体的Handler（处理器），生成Handler（处理器）对象和一些拦截器返回给DispatcherServlet（前端控制器）。 DispatcherServlet（前端控制器）通过返回的信息选择合适的HandlerAdapter（处理器适配器）。 HandlerAdapter（处理器适配器）会调用并执行这个Handler（处理器），这个Handler（处理器）也就是对应的Controller类。 Controller执行完后，返回一个ModelAndView对象或String对象（实际企业开发中都是返回String对象）给HandlerAdapter（处理器适配器）再返回给DispatcherServlet（前端控制器）。 DispatcherServlet（前端控制器）根据返回的String对象，调用ViewResolver（视图解析器）返回对应具体的视图。 DispatcherServlet（前端控制器）对视图进行渲染，返回给用户。 图解：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
        <tag>Spring MVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC和MyBatis、Hibernate]]></title>
    <url>%2F2019%2F06%2F15%2FJDBC%E5%92%8CMyBatis%E3%80%81Hibernate%2F</url>
    <content type="text"><![CDATA[1. JDBC1.1 JDBC简介JDBC（Java DateBase Connectivity，Java数据库连接）是用于操作数据库的Java API，封装在java.sql包中，它规定了一系列的接口和类以及方法，他提供了数据库访问和操作的规范。 通过JDBC我们可以很轻松地让Java程序访问和操作各种关系型数据库（比如MySQL、SQL Server等）。使得开发人员专注于编写业务逻辑。 使用JDBC的主要步骤： 连接数据库，注册驱动和数据库信息。 操作Connection，打开Statement对象。 通过Statement对象执行SQL，返回结果到ResultSet对象。 使用ResultSet读取数据，然后通过代码转化为具体的POJO对象。 关闭数据库连接。 1.2 Spring JDBC但其实使用传统JDBC，对数据库访问和操作还是十分繁琐。 所以在Spring框架中，Spring对JDBC API再次进行了封装，封装在org.springframework.jdbc包中，简化了操作，大大降低了JDBC API的使用难度。 Spring中提供了JdbcTemplate类，这是Spring JDBC中最核心的类，类中提供了大量的方法操作数据库。 非Spring Boot使用Spring JDBC的主要步骤： 配置文件中配置DataSource的Bean，也就是数据源。 将DataSource的Bean注入到JdbcTemplate的Bean中。 将JdbcTemplate的Bean注入到Dao层的类中。 Dao层的类调用JdbcTemplate的方法进行数据库操作。 1.3 Spring Boot中整合Spring JDBCSpring Boot中使用Spring JDBC更简便。 主要步骤： pom.xml文件中引入jdbc依赖。 application.yml配置文件中配置数据源。 Dao层的类注入JdbcTemplate，调用JdbcTemplate的方法进行数据库操作。 注意： Spring Boot默认使用HikariCP作为数据源，如果要更换数据源，在application.yml配置文件spring.datasource.type指定数据源。 2. MyBatisMyBatis也是对JDBC再次进行了封装，MyBatis框架是一种ORM（Object Relational Mapping，对象关系映射）框架，它将Java持久化对象和关系型数据库中的表相互映射。 Spring Boot中整合MyBatis有两种方式： 使用配置文件版MyBatis（SQL语句写在***Mapper.xml文件中） 使用注解版MyBatis（SQL语句直接写在注解内） 具体可以参考： https://fuyuanyua.github.io/2019/04/10/Spring-Boot%E6%95%B4%E5%90%88MyBatis/ 3. HibernateHibernate也是对JDBC进行了封装，也是一种ORM框架，它将Java持久化对象和关系型数据库中的表相互映射。 4. 对比MyBatis和Hibernate MyBatis是半自动映射框架，除了提供POJO和对应的映射关系外，SQL语句也要自己编写。 Hibernate是全表映射框架，只需提供POJO和对应的映射关系，SQL语句会自动生成。 两中框架各自有各自的优势，在不同的项目中由开发者自行选择使用哪一种框架]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[详解Spring Boot主启动类]]></title>
    <url>%2F2019%2F06%2F12%2F%E8%AF%A6%E8%A7%A3Spring-Boot%E4%B8%BB%E5%90%AF%E5%8A%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. Spring Boot主启动类Spring Boot主启动类以xxxApplication来命名，类中定义一个main方法来启动Spring Boot项目。 示例： 123456@SpringBootApplicationpublic class SneakerBillApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SneakerBillApplication.class, args); &#125;&#125; 2. @SpringBootApplication注解通过上面可以看出Spring Boot主启动类标注了@SpringBootApplication注解，点击它进入源码，我们可以看出@SpringBootApplication其实是一个组合注解： 1234567891011121314151617181920212223242526272829303132333435363738@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = &#123;@Filter( type = FilterType.CUSTOM, classes = &#123;TypeExcludeFilter.class&#125;), @Filter( type = FilterType.CUSTOM, classes = &#123;AutoConfigurationExcludeFilter.class&#125;)&#125;)public @interface SpringBootApplication &#123; @AliasFor( annotation = EnableAutoConfiguration.class ) Class&lt;?&gt;[] exclude() default &#123;&#125;; @AliasFor( annotation = EnableAutoConfiguration.class ) String[] excludeName() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackages" ) String[] scanBasePackages() default &#123;&#125;; @AliasFor( annotation = ComponentScan.class, attribute = "basePackageClasses" ) Class&lt;?&gt;[] scanBasePackageClasses() default &#123;&#125;;&#125; @SpringBootApplication由很多注解组成，我们主要关注下面这三个注解： @SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 2.1 @SpringBootConfiguration注解@SpringBootConfiguration注解也是一个组合注解，点击 @SpringBootConfiguration进入源码： 123456@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 主要注解的层级关系： @SpringBootConfiguration @Configuration @SpringBootConfiguration注解内部最重要的还是@Configuration注解，被@Configuration标注的类表示这是一个配置类同时配置类自身也会被纳入容器，类中用@Bean标注的方法其返回值将会被注册纳入容器当作组件（Bean），该组件的id默认为方法名。 2.2 @EnableAutoConfiguration注解@EnableAutoConfiguration注解也是一个组合注解，点击 @EnableAutoConfiguration进入源码： 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 主要注解的层级关系: @EnableAutoConfiguration @AutoConfigurationPackage @Import({Registrar.class}) @Import({AutoConfigurationImportSelector.class}) 主要关注@Import({AutoConfigurationImportSelector.class})注解，它导入了AutoConfigurationImportSelector类，AutoConfigurationImportSelector类会将项目需要的所有自动配置类（比如项目引入了Redis依赖，那么会自动将Redis自动配置类纳入Spring容器，无需我们手动去配置Redis了）纳入Spring容器。免去了我们手动写xml配置文件。 2.3 @ComponentScan注解完成自动扫描组件的功能。 会将Spring Boot项目主启动类所在包及其子包下的所有组件（Bean）扫描到容器，比如被@Component、@Controller等注解标注的类，都会被自动扫描到并被纳入Spring容器。 2.4 总结 @SpringBootApplication @SpringBootConfiguration @Configuration @EnableAutoConfiguration @AutoConfigurationPackage @Import({Registrar.class}) @Import({AutoConfigurationImportSelector.class}) @ComponentScan]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的AOP]]></title>
    <url>%2F2019%2F06%2F10%2FSpring%E4%B8%AD%E7%9A%84AOP%2F</url>
    <content type="text"></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的Bean]]></title>
    <url>%2F2019%2F06%2F09%2FSpring%E4%B8%AD%E7%9A%84Bean%2F</url>
    <content type="text"><![CDATA[1. Bean的定义Bean是一个被实例化被纳入Spring容器管理的对象，我们称Bean叫组件。 1. Bean的注册Spring中注册Bean有三种途径： 基于配置文件注册 基于注解注册（推荐） @Bean方式 1.1 基于xml配置文件注册Spring支持.xml和.properties两种格式的配置文件来注册Bean，xml文件比较常用。 示例： 比如在com.example.springcloud.dao包下有一个UserDao类，则xml文件这样配置 1&lt;bean id="userDao" class="com.example.springcloud.dao.UserDao" /&gt; 注册一个Bean通常指定id和class即可，如果没有指定id也没指定name，Spring默认将class名当作id名。 1.2 基于注解注册Spring Boot推荐无xml文件来进行开发，所以推荐使用注解来注册Bean，Spring对Bean的注册有一系列的注解： @Component：可以标注在任何层的类上。 @Repository：标注在DAO层的类上。 @Service：标注在Service层的类上。 @Controller：标注在Controller层的类上。 以上四个注解功能是相同的，标识在类上，Spring就会自动把这个类注册Bean纳入容器，但是实际开发中分层开发，所以各层的类用各层对应的注解。 示例： 123456@Repository("userDao")public class UserDao &#123; /** * 其余代码省略 **/&#125; 以上注册Bean和1.1中基于xml注册Bean是等价的。 如果不指定Bean名，即直接@Repository，Bean的id默认为类名（首字母会变小写）。 1.3 @Bean方式参考以下： https://fuyuanyua.github.io/2019/06/07/Spring-Bean%E6%B3%A8%E8%A7%A3/ 2. Bean的装配Bean的装配即Bean的依赖注入（DI），依赖注入在我上一篇博文中已经讲过，除了讲过的基于xml文件的两种方法： setter方法注入 构造方法注入 其实还有： 基于注解的装配（推荐） 2.1 基于xml配置文件装配在我上一篇博文已经讲过，我便不再重复叙述，链接： https://fuyuanyua.github.io/2019/06/09/Spring%E4%B8%AD%E7%9A%84IoC%E5%92%8CDI/ 2.2 基于注解装配Spring Boot推荐无xml文件来进行开发，所以推荐使用注解来装配Bean，Spring对Bean的装配有一系列的注解： @Autowired：可以标注在属性、方法或者构造方法上。标注在属性上是最常用最简便的，根据Bean的类型自动装配（Spring自动找到容器中对应属性类型的Bean并注入）。 示例： 1234567891011@Servicepublic class UserServiceImpl implements UserService &#123; // 标注在属性上，Spring自动在容器中找到UserDao类型的Bean注入 @Autowired private UserDao userDao; /** * 其余代码省略 **/&#125; @Qualifier：配合@Autowired使用，当容器中有多个相同类型的Bean时，Spring不知道装配哪个Bean，于是用@Qualifier指定Bean的id来确定装配哪个Bean。 示例： 123456789101112131415@Servicepublic class UserServiceImpl implements UserService &#123; /** * @Qualifier配合@Autowired一起标注在属性上 * Spring自动在容器中找到id为userDao的Bean注入 **/ @Autowired @Qualifier("userDao") private UserDao userDao; /** * 其余代码省略 **/&#125; @Resource：功能和@Autowired一样，但是@Resource默认根据Bean的id进行自动装配。 示例： 1234567891011@Servicepublic class UserServiceImpl implements UserService &#123; //标注在属性上，Spring自动在容器中找到id为userDao的Bean注入 @Resource（name = "userDao"） private UserDao userDao; /** * 其余代码省略 **/&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中的IoC和DI]]></title>
    <url>%2F2019%2F06%2F09%2FSpring%E4%B8%AD%E7%9A%84IoC%E5%92%8CDI%2F</url>
    <content type="text"><![CDATA[1. IoC简介IoC（Inversion of Control）即控制反转，它不是一种技术，而是一种思想，是Spring的核心思想。 不使用Spring之前，在一个类的对象中要调用其他类的对象，通常直接用new来创建被调用者对象实例，这样大大增加耦合性。 使用Spring之后，我们只声明被调用者对象，new被调用者对象实例的工作全部交给Spring容器，无需自己去new，也就是控制权交给了Spring容器，这就是控制反转。 2. DI简介DI（Dependency Injection）即依赖注入，是IoC的具体实现方式。 2.1 DI的实现依赖注入有两种实现方式： setter方法注入 构造方法注入 setter方法注入比较常用。具体参考以下博文： https://blog.csdn.net/SunnyYoona/article/details/50631178]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring的核心容器]]></title>
    <url>%2F2019%2F06%2F08%2FSpring%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. Spring的核心容器Spring框架的主要功能都是通过Spring的核心容器来实现的，Spring提供了两种核心容器： BeanFactory ApplicationContext 1.1 BeanFactory（基本不用这个方式，了解即可） BeanFactory是一个接口，来自org.springframework.beans.factory包，是基础的IoC（控制反转）容器，提供了完整的IoC服务支持，主要负责初始化各种Bean，并调用他们的生命周期方法。 XmlBeanFactory类来自org.springframework.beans.factory.xml包，是BeanFactory接口的实现类，但是在最新Spring中（我用的是5.1.5版本）已经被弃用，我们也无需再讨论了。 1.2 ApplicationContextApplicationContext也是一个接口，来自org.springframework.context包，它是BeanFactory接口的子接口，不仅包含BeanFactory所有功能，还添加了对国际化、资源访问等功能的支持。 ApplicationContext接口的继承关系图： ApplicationContext接口有很多实现类比如常用的ClassPathXmlApplicationContext类和FileSystemXmlApplicationContext类，通过new实现类即可完成ApplicationContext对象的实例化。 这样就完成了Spring容器的创建。 代码示例： 12345// 类路径中去查找并加载配置文件applicationContext.xmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");// 绝对路径中去查找并加载配置文件applicationContext.xmlApplicationContext applicationContext = new FileSystemXmlApplicationContext("D:/User/applicationContext.xml"); ClassPathXmlApplicationContext类的继承关系图： FileSystemXmlApplicationContext类的继承关系图：]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring框架简介]]></title>
    <url>%2F2019%2F06%2F08%2FSpring%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring @Bean注解]]></title>
    <url>%2F2019%2F06%2F07%2FSpring-Bean%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. @Bean注解的作用@Bean是作用在方法上的注解，将此方法返回的对象作为组件（Bean）纳入容器，组件id默认为方法名。 主要作用在@Configuration注解的类的方法上。 代码示例： 12345678910// 标识配置类@Configurationpublic class ConfigBean &#123; // 向容器中添加RestTemplate组件,直接通过此组件可调用REST接口 @Bean public RestTemplate getRestTemplate() &#123; return new RestTemplate(); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据类型(m)括号内数字m的作用]]></title>
    <url>%2F2019%2F06%2F06%2FMySQL-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-m-%E6%8B%AC%E5%8F%B7%E5%86%85%E6%95%B0%E5%AD%97m%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[比如我在MySQL中建表： 123456789101112131415drop table if exists `bill`;create table `bill` ( `bill_id` int(8) not null auto_increment, `sneaker_name` varchar(50) default null, `sneaker_amount` int(8) default null, `purchase_price` double(8,2) default null, `selling_price` double(8,2) default null, `express_price` double(8,2) default null, `profit` double(8,2) default null, `provider_id` int(8) not null, `gmt_create` datetime default current_timestamp, `gmt_modified` datetime default current_timestamp, primary key (`bill_id`), foreign key (`provider_id`) references `provider`(`provider_id`) ) engine=InnoDB auto_increment=1 default charset=utf8; 1. int(8)其中的int(8)是指int占8字节吗？ 显然不是，在MySQL中int型是规定了长度的，即32位，4字节，表示十进制数字范围从-2^31 ~ 2^31。无论int(m)，m的数字是多少，比如int(8)和int(11)，他们一样都占4字节。 int(m)只是规定了显示的最小长度，int(8)表示规定了显示的最小长度为8，int(8) zerofill，表示长度不足时自动补足0，比如你插入1，他会显示00000001。 int(8)只有在后面跟了zerofill时才有意义，不足会自动补0，否则毫无意义，比如我上面建表的int(8)是毫无意义的，直接int即可。 如果直接写int，系统默认是int(11)。 2. varchar(50)在MySQL5.0以后，varchar(50)表示最大可以存储50个字符的可变长字符串。 是50字符而不是50字节。 字符可以是数字、英文和utf-8汉字（一个汉字3字节）等。 3. double(8,2)double(m,d)，m表示总位数（包括整数位和小数位）最长为m，d是小数位的长度限制，如果省略m和d，将值存储到硬件允许的限制。 double(8,2)表示允许存储最长总共8位的数字，小数点占2位。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度优先遍历和广度优先遍历]]></title>
    <url>%2F2019%2F06%2F05%2F%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E5%92%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树]]></title>
    <url>%2F2019%2F06%2F04%2F%E7%BA%A2%E9%BB%91%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 红黑树1.1 定义红黑树（Red Black Tree）是一种自平衡的二叉排序树，它符合二叉排序树的特性，还有以下特性： 所有结点不是红色就是黑色。 根节点为黑色。 每个叶子结点都是黑色的空节点。 所有红色结点的两个子节点都是黑色结点。 任意结点到其所有叶子结点的所有路径都包含相同数目的黑色结点。 1.2 图示以下就是一棵红黑树： 1.3 插入红黑树按照二叉排序树的插入规则进行插入，插入的新节点都标记为红色（如果标记为黑色破坏了特性5，一条路径上多出一个黑色结点，而其他路径不多出一个黑色结点，调整起来会极其困难）。 插入的情况很多，所以需要对结点进行变色，或者左旋、右旋来维持这棵红黑树的特性。 具体参考维基百科： https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91#%E6%8F%92%E5%85%A5 1.4 删除红黑树的删除操作和二叉排序树的删除操作如出一辙，但是删除后为了维持红黑树的特性（主要是满足特性4和特性5），还要做许多操作。 如果被删除的结点是红色的，那么删除这个结点对红黑树的特性没有任何影响。 如果被删除的结点是黑色的，那么可能就破坏了特性4或者特性5，需要进一步操作来维持红黑树特性。 红黑树的删除操作真的很复杂，我无能为力再讲下去。。。 可以参考： https://www.cnblogs.com/nullllun/p/8214599.html#autoid-3-2-0]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉排序树和平衡二叉树]]></title>
    <url>%2F2019%2F06%2F03%2F%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%E5%92%8C%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[1. 二叉排序树1.1 定义二叉排序树（Binary Sort Tree）又称二叉查找树（Binary search Tree），简称BST，它有以下性质： 若一棵二叉排序树的左子树不为空，则左子树所有结点的值都小于这棵二叉排序树的根节点的值。 若一棵二叉排序树的右子树不为空，则右子树所有结点的值都大于这棵二叉排序树的根节点的值。 这棵二叉排序树的左右子树也分别都是二叉排序树。 1.2 图示以下就是一棵二叉排序树： 1.3 其他对一棵二叉排序树进行中序遍历（左子树 -&gt; 根节点 -&gt; 右子树），就能得到一个有序序列，比如对上图的二叉排序树进行中序遍历就得到（30, 38, 40, 45, 48, 50, 60, 70, 75, 80）。 2. 平衡二叉树2.1 定义平衡二叉树（Balanced Binary Tree），又称AVL树，它有以下性质： 它的左右子树都是平衡二叉树。 它的左右子树的深度之差的绝对值不超过。 将二叉树节点上的平衡因子（Balance Factor）定义为该节点的左子树深度减去右子树深度。所以一颗平衡二叉树上所有结点的平衡因子只能为-1、0或1。 2.2 图示非平衡二叉树： 平衡二叉树： 2.3 插入当插入新节点时，可能会使这棵平衡二叉树失去平衡，这时就要调整最小的那棵失去平衡的子树，进行平衡化操作使整棵树重新平衡。 平衡化操作分为： 单次右旋 单次左旋 先左旋后右旋 先右旋后左旋 2.3.1 单次右旋如下图： 发生在LL的时候，即在一棵平衡二叉树的左子树的根节点的左叶子结点新插入结点，这样破坏了树的平衡，需要进行单次右旋使树重新平衡。 单次右旋如何操作直接看图： 2.3.2 单次左旋发生在RR的时候，即在一棵平衡二叉树的右子树的根节点的右叶子结点新插入结点，这样破坏了树的平衡，需要进行单次左旋使树重新平衡。 单次左旋和单次右旋的思想是一样的，直接看图： 2.3.3 先左旋后右旋发生在LR的时候，即在一棵平衡二叉树的左子树的根节点的右叶子结点新插入结点，这样破坏了树的平衡，需要进行先左旋后右旋使树重新平衡。 图略，思想和先右旋后左旋一样。 2.3.4 先右旋后左旋发生在RL的时候，即在一棵平衡二叉树的右子树的根节点的左叶子结点新插入结点，这样破坏了树的平衡，需要进行先右旋后左旋使树重新平衡。 直接看图： 2.4 删除要了解一棵平衡二叉树如何删除一个结点，首先我们要了解二叉排序树如何删除一个结点。 对于二叉排序树，假设要删除结点A，有三种情况： 结点A是叶子结点。 结点A的左子树或右子树为空。 结点A的左子树和右子树都不为空。 分别有三种对策： 对于情况1，直接删除结点A即可。 对于情况2，结点A的父结点绕过结点A，指向结点A的右子树（如果结点A的左子树为空），或指向结点A的左子树（如果结点A的右子树为空），然后删除结点A即可。 对于情况3，找到结点A的前驱（左子树中值最大的结点）或者结点A的后继（右子树中值最小的结点），并把前驱或者后继的值复制到结点A中，最后将前驱或者后继删除。 平衡二叉树的删除策略和二叉排序树一样，不过最后可能会失去平衡，需要对树进行平衡化操作。 （小声bb，网上很多人写的博客真不怎样，用自以为很幽默风趣的话来描述一个知识点，却模棱两可描述不清楚，而且那些“幽默风趣”的话其实很无聊，比如“举个栗子”等等，呕）]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B树和B+树]]></title>
    <url>%2F2019%2F05%2F31%2FB%E6%A0%91%E5%92%8CB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[要了解B+树，我们首先了解B树。 1. B树B树即B-树（中间不是减号，Balance Tree），是一种多路平衡查找树。 我们描述一颗B树要指定它的阶数，阶数表示了一个结点最多可以有多少个孩子结点。 比如： 当阶数m=3时，则表示该B树一个结点最多有三个孩子结点。 当阶数m=2时，则表示该B树一个结点最多有两个孩子结点，该B树其实就是二叉排序树。 1.1 定义规定了一颗m阶的B树要有以下特征： 树中每个结点最多有m个孩子结点，树中每个结点最多有m-1个元素。 根结点至少要有两个孩子结点。 中间结点至少要有seil(m / 2)个孩子结点。 中间结点和叶子结点至少要有seil(m / 2) - 1个元素。 每个结点中的元素都按照从左到右从小到大的顺序排列，每个元素的左子树中的所有元素都小于它，每个元素的右子树中的所有元素都大于它。 所有叶子结点都位于同一层。 1.2 图示以下是一颗3阶B树。 B树中所有节点都存储data。 1.3 B树的操作可以参考以下博文： https://www.yiibai.com/data_structure/b-tree.html 1.4 应用现实应用B树，B树是非常“矮胖”的，即树的阶数特别大，如m = 1000，那么树的一个结点最多可以储存999个元素，这样一来树的高度就特别小。 B树主要应用在数据库的索引上，如非关系型数据库MongoDB的索引就是用了B树这种数据结构，大大减少了磁盘IO次数，大大提高了性能。 注意： 数据库索引都是存储在磁盘上的，当数据量非常庞大时，索引的大小可能有几个G。 我们利用索引查询时，不可能把整个索引都加载到内存，只能逐一加载每一个磁盘页，每个磁盘页对应着树的每一个结点。 这样一来树的最大高度决定了磁盘IO的最大次数，所以使用“矮胖”的B树。 B树在查询的比较次数并不比平衡二叉树少，因为单一结点里存储的元素特别多。但是相比磁盘IO，内存中的耗时几乎可以忽略，所以只要树高度足够低，IO次数足够少，就大大提高性能。想象一下，上百万的数据中查询只发生了3次IO，性能是如何的强大啊！ 2. B+树2.1 定义B+树其实是B树的一种变体，有着比B树更高的查询性能。 B+树除了有B树的行政，还有以下特点： 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 2.2 图示以下是一颗3阶B+树。 B+树只有叶子结点存储data。MyISAM中data存储key对应的那行数据的物理地址。InnoDB中data存储key所对应那行除key外的所有数据。 2.2 应用关系型数据库如MySQL的MyISAM表和InnoDB表等的索引就是使用了B+树的数据结构，B+树相比于B树： 总数据量相等的情况下，B+树单一结点存储更多元素，使树高度降低，IO次数减少。 查询性能稳定，因为每一次查询都要查询到叶子结点。而B树不稳定，最优查询到根节点，最坏查询到叶子结点。 所有叶子结点形成有序链表，范围查询性能大大优于B树]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL索引]]></title>
    <url>%2F2019%2F05%2F31%2FMySQL%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[在MySQL中，不同引擎的表，其索引的实现方式也不同，下面介绍MyISAM存储引擎的表和InnoDB存储引擎的表他们的索引的实现方式。 1. MyISAMMySQL 5.x以前，使用MyISAM作为默认存储引擎，MyISAM使用表级锁。 MyISAM使用B+树作为索引的数据结构。 假设数据库中有一张MyISAM存储引擎的表，有三个列（字段）col1、col2、col3，表每一行最前面的数字代表这一行数据的物理地址。 上图就是对col1字段建立索引。B+树的叶子结点key存储col1字段中的值，data域存放key所对应的记录的地址。这种索引叫非聚集索引。 所以对col1字段建立索引后，查询过程是先查询指定key，若存在，得到对应的data域中的值，然后再以data域中的值作为物理地址，读取到这一行的数据。 2. InnoDBMySQL 5.x以后，使用InnoDB作为默认存储引擎，InnoDB使用行级锁。 InnoDB也使用B+树作为索引的数据结构。但具体实现方式与MyISAM不同。 MyISAM数据文件和索引文件是两个文件，索引文件仅仅保存key和key对应那一行数据的地址，不保存数据。但是InnoDB数据文件本身就使用了B+树数据结构，InnoDB数据文件是数据文件本身同时也是以主键建立的索引文件。 假设数据库中有一张InnoDB存储引擎的表，有三个列（字段）col1、col2、col3，假设col1为主键。表每一行最前面的数字代表这一行数据的物理地址。 以上图就是以主键col1建立的索引。B+树的叶子结点key存储主键的值，data域直接保存了除了主键的完整的一条数据。 这种索引叫聚集索引，所以InnoDB表必须要有主键（MyISAM可以没有），如果没有显式指定，MySQL会自动选择一个可以唯一标识数据记录的列作为主键，若没有这种列，MySQL会自动为InnoDB生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。 3. 聚集索引和非聚集索引的区别简单来说： 聚集索引：确定了表中数据的物理存储顺序，聚集索引的叶子结点data存储了数据本身。 非聚集索引：非聚集索引的叶子结点data存储的是数据的物理地址。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单介绍Solr]]></title>
    <url>%2F2019%2F05%2F30%2F%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DSolr%2F</url>
    <content type="text"><![CDATA[1. solr简介Lucene是apache下的一个开源的全文搜索引擎工具包，而Solr则是基于Lucene的企业级开源全文搜索服务器，Solr可以独立运行在Jetty、Tomcat等这些Servlet容器中。 2. 最大特点：倒排索引]]></content>
      <categories>
        <category>Solr</category>
      </categories>
      <tags>
        <tag>Solr</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解HashMap]]></title>
    <url>%2F2019%2F05%2F27%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap%2F</url>
    <content type="text"><![CDATA[HashMap的默认初始容量为16。 1. HashMap的数据结构Java中HashMap的数据结构： JDK1.7：数组+链表的组合。 JDK1.8：数组+链表/红黑树的组合。 2. HashMap的属性2.1 重要的常量通过源码查看HashMap的一些重要常量： 123456789101112131415161718192021222324252627282930/** * 默认初始容量为1向左移位4位，即00000001变成00010000，也就是1乘以2的4次方 * 即默认初始容量（桶的数量，也就是Node&lt;K,V&gt;[] table数组的长度）为16 */static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16/** * 最大容量（桶的数量）为1向左移位30位，也就是1乘以2的30次方 */static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;/** * 默认加载因子为0.75 */static final float DEFAULT_LOAD_FACTOR = 0.75f;/** * 链表转换为红黑树的阈值 */static final int TREEIFY_THRESHOLD = 8;/** * 红黑树转换为链表的阈值 */static final int UNTREEIFY_THRESHOLD = 6;/** * 由链表转换为红黑树的最小容量（桶的数量）阈值 */static final int MIN_TREEIFY_CAPACITY = 64; 2.2 重要的变量通过源码查看HashMap的一些重要变量： 12345678910111213141516171819202122232425/** * 储存桶的数组 */transient Node&lt;K,V&gt;[] table;/** * HashMap中存储的键值对的数量 */transient int size;/** * HashMap结构修改的次数 */transient int modCount;/** * threshold = capacity * load factor * 扩容阈值，当size &gt;= threshold，就会扩容 */int threshold;/** * 加载因子 */final float loadFactor; 2.3 认识Node&lt;K,V&gt;在2.2有一段源码transient Node&lt;K,V&gt;[] table;，可知table是存储Node&lt;K,V&gt;的数组，可Node&lt;K,V&gt;是什么呢？ ps：transient 关键字的作用是： 一个类实现了序列化接口，那么这个类的所有属性和方法都会被序列化，但类中某些属性我们不想让它被序列化，那么就在这个属性前面加上transient 关键字，这个属性就不会被序列化。 查看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; // hash(key)方法的返回值 final int hash; // 键 final K key; // 值 V value; // 下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; Node翻译为节点，Node&lt;K,V&gt;是HashMap的一个内部类，实现了Map.Entry&lt;K,V&gt;接口，本质上就是一个键值对。但Node还封装了hash属性和next属性（这样就能实现链表或者红黑树）。 注意： hash属性就是Node中key通过hash(key)方法的返回值。（在下面4.1.2和4.1.3会解释原理） next就是下一个节点。 3. HashMap的构造方法HashMap部分源码： 1234567891011121314151617181920212223242526272829303132333435363738394041public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; /** * 构造方法一 */ public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125; /** * 构造方法二 */ public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125; /** * 构造方法三 */ public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125; /** * 构造方法四 */ public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125;&#125; 3.1 HashMap的四个构造方法 public HashMap(int initialCapacity, float loadFactor)：构造一个指定初始容量和加载因子的空HashMap。 public HashMap(int initialCapacity)：构造一个指定初始容量和默认加载因子（0.75）的空HashMap。 public HashMap()：构造一个默认初始容量（16）和默认加载因子（0.75）的空HashMap。 public HashMap(Map&lt;? extends K, ? extends V&gt; m)：用现有的一个Map来构造一个HashMap。 以上提到了两个参数：initialCapacity（初始容量）和loadFactor（加载因子）。 初始容量表示HashMap中桶的数量，也就是源码中table数组的长度，默认初始容量为16。 加载因子是衡量一个散列表的空间使用程度。如果加载因子变大（加载因子可以大于1），表示空间利用率变大，但同时键与键碰撞率加大，链表长度变长，增删改查操作效率降低；加载因子变小，空间利用率降低，但同时键与键的碰撞率变小，链表长度变低，增删改查效率提高。默认值为0.75，是JDK开发者经过充分计算得出的最优值，我们一般不去修改。 3.2 容量重计算当然，我们设置一个初始容量，HashMap并不一定直接采用我们设置的值，通过分析源码可以知道： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125; 如果我们设置的初始容量是2的幂，则HashMap直接采用我们设置的值。 若不是，HashMap会采用大于该值的第一个2的幂（比如我们设置3，则是4；设置7，则是8）。 注意： 通过以上方法得到的capacity却在构造方法中被初始化赋值给了thresholdthis.threshold = tableSizeFor(initialCapacity);，我百思不得其解，觉得应该是this.threshold = tableSizeFor(initialCapacity) * this.loadFactor;才对，但其实在构造方法中并没有对table数组初始化，table的初始化被推迟到了put方法中，put方法会重新对threshold进行计算。 JDK底层源码很多都采用了移位运算，大大提高效率。 3.3 推荐使用的构造方法《阿里巴巴Java开发手册》推荐： 4. put方法HashMap的put方法源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;/** * Implements Map.put and related methods * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don't change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 判断table数组是否为空，为空则调用resize()方法对table数组初始化 // HashMap的构造函数都不会初始化table，所以第一次put时table数组一定是空的，会被初始化 // table被延迟到了put时才初始化，而不是在构造方法时初始化 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 根据桶数组length - 1和key的hash进行“与”运算得到key对应的数组下标，也就是对应的桶 // hash经过hash(Object)方法得到 // 如果对应桶中为空，新建对应Node放入桶中 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 到这说明对应桶中不为空 else &#123; Node&lt;K,V&gt; e; K k; // 判断已经在桶中存在的key和待放入的key是否相等，相等满足两个条件： // 1.hash相等 // 2.两者'=='或者'.equals' if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 如果条件判断成立，Node e保存已经在桶中存在的Node p e = p; // 到这说明对应桶已经被占用且桶中存放的key与待放入的key不相等 // 判断对应桶中存放的是否是红黑树类型 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 否则对应桶中存放的是链表类型 else &#123; // 遍历链表 for (int binCount = 0; ; ++binCount) &#123; // (e = p.next) == null说明已经遍历到链表尾节点了 // 说明链表中没有key与待放入的key相等 if ((e = p.next) == null) &#123; // 新建待放入key对应的节点插入到尾节点后面 p.next = newNode(hash, key, value, null); // 如果链表长度大于等于8，把链表转换为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出for循环 break; &#125; // 如果在遍历链表时找到了key与待放入的key相等 // 直接跳出for循环 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; // 退出时Node e保存的是在链表中找到的key对应的Node // 将Node e赋给Node p p = e; &#125; &#125; // 到这说明要么e为空，新建了Node插到了链表尾 // 要么e不为空，说明在桶中找到了key与待放入的key相等，e保存了与待放入的key相等的桶中的key对应的Node // e不为空 if (e != null) &#123; // existing mapping for key V oldValue = e.value; // 旧值存在或者旧值为null，用新值覆盖旧值 if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // HashMap的结构修改次数加1 ++modCount; // 判断是否要扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 4.1 参数分析 int hash：通过hash(key)得到，这个方法查看4.3。 K key和V value：待储存的键值对。 boolean onlyIfAbsent：false boolean evict：true 4.2 resize()方法源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; resize()方法用于以下两种情况： put方法中初始化table。 扩容，size &gt;= threshold的时候：size变量即HashMap中节点（就是Node键值对）的数量，threshold = capacity * load factor 注意： 分析resize()源码可知，put方法中使用resize()方法初始化table时，有两种情况： 使用不指定initialCapacity的HashMap构造方法，初始化长度为16的table。 使用指定initialCapacity的HashMap构造方法，初始化长度为超过指定initialCapacity的最小2次幂的table。 每次扩容都会新建一个table，新table大小为原table大小的2倍。 扩容时，会将原table中的各节点通过算法重新散列到新table中，但各节点在新旧table中有一定联系：要么下标相同，要么相差一个原table的大小。 4.3 hash(Object)方法源码： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 如果key为空，则hash值为0（这也是为什么HashMap的key可以为null的原因）。 如果key不为空，则hash值为：将key的hashCode与key的hashCode无符号右移16位得到的结果进行异或运算得到的结果。（所以自定义类作为HashMap的key要重写hashCode()方法： https://fuyuanyua.github.io/2019/05/14/Java%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84%E9%94%AE/ ） 使用hash(Object)方法进行二次hash计算，而不直接采用.hashCode()，主要是为了让键值对更均匀的分布在各个桶中，减少键与键的碰撞，降低链表长度，提高增删改查性能。 4.4 总结 在put数据之前会检查table是否为空，因为HashMap的构造方法里都没有对tabel初始化，所以第一次put的时候table一定为空，用resize()方法对table进行初始化。 put时会对待储存的key和桶中的key进行比较是否相等，相等的条件是p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))。（所以自定义类作为HashMap的key要重写.equals方法： https://fuyuanyua.github.io/2019/05/14/Java%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84%E9%94%AE/ ） 如果遍历桶中链表没找到key与待储存的key相等，则新建待储存key对应的Node插到链表尾。 每次插入结束都会检查size是否大于threshold，大于则调用resize()方法。 链表长度超过8就将链表转换为红黑树。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述分派]]></title>
    <url>%2F2019%2F05%2F23%2F%E7%AE%80%E8%BF%B0%E5%88%86%E6%B4%BE%2F</url>
    <content type="text"><![CDATA[1. 分派分派指的是在Java中对方法的调用，分派可分为： 静态分派 动态分派 2. 静态分派先区分静态类型和实际类型：假设Animal为父类，Dog为子类，Animal animal = new Dog(); 则对象animal的静态类型为Animal，在编译时便确定。 实际类型为Dog，在运行时才确定。 根据对象的静态类型来确定执行哪个方法版本，叫做静态分派，典型应用为方法重载。 发生在编译阶段，静态分派的动作不是JVM来执行的。 3. 动态分派根据对象的实际类型来确定执行哪个方法版本，叫做动态分派，典型应用为方法重写。 发生在运行时期，动态分派由JVM来执行。 动态分派的实现是在方法区建立方法表： 如果子类没有重写父类该方法，则子类虚方法表中该方法指向父类该方法的入口地址。 如果子类重写了父类该方法，则子类虚方法中该方法指向子类重写后的该方法入口地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事务的隔离级别]]></title>
    <url>%2F2019%2F05%2F23%2F%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[详见本博文： https://fuyuanyua.github.io/2019/04/09/Spring-Boot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程start方法和run方法的区别]]></title>
    <url>%2F2019%2F05%2F21%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8Bstart%E6%96%B9%E6%B3%95%E5%92%8Crun%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[start()方法： 是Thread类中的一个方法。 启动主线程以外的线程，唯一方法就是调用start()方法，真正实现多线程。 调用start()方法后，start()方法调用Thread类（也就是自身类）的native方法start0()，这时此线程就处于Runnable状态，一旦得到系统的调度，就执行run()方法，run()方法代码执行完，此线程便终止。 run()方法： 最初是在Runable接口被定义的抽象方法。 无论是在Thread类中被重写，还是在继承了Thread类的子类中被重写，run()方法都只是一个普通的方法。 如果直接调用run()方法，依然在主线程中按顺序执行，无法实现多线程。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java实现多线程]]></title>
    <url>%2F2019%2F05%2F20%2FJava%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. Java实现多线程四种方式 继承Thread类。 实现Runable接口。 实现Callable接口。 线程池。 2. 继承Thread类2.1 简介Thread类来自java.lang.Thread。 Thread类的继承关系： Thread类实现了Runable接口和Runable接口的run()方法。 2.2 示例以下创建MyThread类继承Thread类，并重写run()方法： 1234567891011121314151617181920212223242526272829/** * @ClassName: MyThread * @Description: 继承Thread类实现多线程 * @Author: LiHaibin * @Date: 2019-05-19 18:37 * @Version: V1.0 **/public class MyThread extends Thread &#123; private String name; public MyThread(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行" + i + "次"); try &#123; /*sleep(3 * 1000);*/ sleep((long) (Math.random() * 10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试代码： 1234567891011121314151617/** * @ClassName: Test * @Description: 测试继承Thread类，实现多线程 * @Author: LiHaibin * @Date: 2019-05-20 15:10 * @Version: V1.0 **/public class Test &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread("a"); MyThread myThread1 = new MyThread("b"); myThread.start(); myThread1.start(); &#125;&#125; 在启动的多线程的时候，需要先通过Thread类的继承类MyThread类的构造方法构造出对象，然后调用MyThread对象的start()方法来运行多线程代码。 2.3 测试效果控制台打印输出： 第一次运行： 123456789101112b运行0次a运行0次b运行1次a运行1次a运行2次b运行2次a运行3次a运行4次b运行3次b运行4次Process finished with exit code 0 第二次运行： 123456789101112a运行0次b运行0次a运行1次b运行1次b运行2次a运行2次a运行3次b运行3次a运行4次b运行4次Process finished with exit code 0 发现两次运行，多线程的代码执行顺序不一样。 3. 实现Runable接口3.1 简介Runable接口来自java.lang.Runnable。 Runable接口仅定义了一个run()抽象方法。 123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; 3.2 示例以下创建MyThread1实现Runnable接口，重写Runnable接口的run()抽象方法： 12345678910111213141516171819202122232425262728/** * @ClassName: MyThread1 * @Description: 调用Runable接口实现多线程 * @Author: LiHaibin * @Date: 2019-05-20 15:45 * @Version: V1.0 **/public class MyThread1 implements Runnable &#123; private String name; public MyThread1(String name) &#123; this.name = name; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 5; i++) &#123; System.out.println(name + "运行" + i + "次"); try &#123; Thread.sleep((long) (Math.random() * 10)); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 测试代码： 123456789101112131415/** * @ClassName: Test1 * @Description: 测试实现Runable接口，实现多线程 * @Author: LiHaibin * @Date: 2019-05-20 16:26 * @Version: V1.0 **/public class Test1 &#123; public static void main(String[] args) &#123; // 新建MyThread1类对象当做Thread对象的target new Thread(new MyThread1("c")).start(); new Thread(new MyThread1("d")).start(); &#125;&#125; 在启动的多线程的时候，需要先通过Thread类的构造方法Thread(Runnable target)构造出对象，然后调用Thread对象的start()方法来运行多线程代码。 Thread类构造方法： 123456789101112131415/** * Allocates a new &#123;@code Thread&#125; object. This constructor has the same * effect as &#123;@linkplain #Thread(ThreadGroup,Runnable,String) Thread&#125; * &#123;@code (null, target, gname)&#125;, where &#123;@code gname&#125; is a newly generated * name. Automatically generated names are of the form * &#123;@code "Thread-"+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer. * * @param target * the object whose &#123;@code run&#125; method is invoked when this thread * is started. If &#123;@code null&#125;, this classes &#123;@code run&#125; method does * nothing. */public Thread(Runnable target) &#123; init(null, target, "Thread-" + nextThreadNum(), 0);&#125; 把Runnable接口的实现类MyThread1的对象向上转型变成Runnable接口的对象target。如果不懂，可以思考一下List&lt;String&gt; list = new ArrayList&lt;&gt;();，List是接口，ArrayList是List接口的实现类，是面向接口编程思想：https://blog.csdn.net/jingshaozhi/article/details/80006464 3.3 测试效果控制台打印输出： 第一次运行： 123456789101112c运行0次d运行0次d运行1次c运行1次c运行2次d运行2次d运行3次c运行3次d运行4次c运行4次Process finished with exit code 0 第二次运行： 123456789101112c运行0次d运行0次d运行1次d运行2次c运行1次c运行2次d运行3次d运行4次c运行3次c运行4次Process finished with exit code 0 发现两次运行，多线程的代码执行顺序依然不一样。 所以：多线程代码执行顺序都是不确定的，每次执行的结果都是随机的。 4. 小结 无论以何种方式实现多线程，启动线程以外的线程，唯一方法就是通过Thread类对象的start()方法。 查看Thread类源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970 /** * Causes this thread to begin execution; the Java Virtual Machine * calls the &lt;code&gt;run&lt;/code&gt; method of this thread. * &lt;p&gt; * The result is that two threads are running concurrently: the * current thread (which returns from the call to the * &lt;code&gt;start&lt;/code&gt; method) and the other thread (which executes its * &lt;code&gt;run&lt;/code&gt; method). * &lt;p&gt; * It is never legal to start a thread more than once. * In particular, a thread may not be restarted once it has completed * execution. * * @exception IllegalThreadStateException if the thread was already * started. * @see #run() * @see #stop() */ public synchronized void start() &#123; /** * This method is not invoked for the main method thread or "system" * group threads created/set up by the VM. Any new functionality added * to this method in the future may have to also be added to the VM. * * A zero status value corresponds to state "NEW". */ if (threadStatus != 0) throw new IllegalThreadStateException(); /* Notify the group that this thread is about to be started * so that it can be added to the group's list of threads * and the group's unstarted count can be decremented. */ group.add(this); boolean started = false; try &#123; start0(); started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; /* do nothing. If start0 threw a Throwable then it will be passed up the call stack */ &#125; &#125; &#125; private native void start0(); /** * If this thread was constructed using a separate * &lt;code&gt;Runnable&lt;/code&gt; run object, then that * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called; * otherwise, this method does nothing and returns. * &lt;p&gt; * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method. * * @see #start() * @see #stop() * @see #Thread(ThreadGroup, Runnable, String) */ @Override public void run() &#123; if (target != null) &#123; target.run(); &#125; &#125; 分析以上源码可以知道，start()方法调用了native方法start0()（使用native关键字说明这个方法是原生函数，也就是这个方法是用C/C++语言实现的，由Java去调用），它将启动一个新的线程，并执行run()方法： 如果是以继承Thread类的方式，执行Thread类的子类重写的run()方法。 如果是以实现Runable接口的方式，执行实现类重写的run()方法。 start()方法的调用后并不是立即执行多线程run()代码，而是使得该线程变为可运行状态（Runnable），什么时候执行是由操作系统调度决定的。 run()方法是多线程的一个接口约定，所有的多线程代码都写在run()方法里面。 多线程代码执行顺序是不确定的。 运行程序main()方法时，JVM便启动一个Java进程，main()是主线程，然后随着调用对象的start()方法，另外的线程也启动了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中线程的生命周期]]></title>
    <url>%2F2019%2F05%2F19%2FJava%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[1. 进程与线程1.1 进程（Process）对于Windows、Mac OS X等操作系统，比如打开一个浏览器就是启动一个浏览器进程，打开一个Word文档就是启动一个Word进程。 进程是系统进行资源分配和调度的一个独立单位，进程是资源分配的最小单位。 多个进程可以在单个处理器上并发执行，互不影响。 一个进程可以有多个线程。 1.2 线程（Thread）有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程。 线程是cpu调度的最小单位。 线程不拥有系统资源。 一个进程可以有多个线程，多个线程共享该进程内存和资源（共享的内存是堆内存和方法区内存，栈内存不共享，每个线程有自己的栈内存）。 多个线程能并发执行。 2. 线程的生命周期线程生命周期有五种状态： 新建状态（New） 就绪状态（Runnable）： 运行状态（Running） 阻塞状态（Blocked） 死亡状态（Dead） 2.1 新建状态（New）新建了一个线程对象。 例： 123// 注：假设MyThread1类是实现了Runable接口的类MyThread1 myThread1 = new MyThread1("c");Thread thread = new Thread(myThread1); 2.2 就绪状态（Runnable）线程对象创建后，其他线程（比如主线程）调用了该线程对象的start()方法，该线程就启动了，变成Runnable状态，位于可运行线程池中，等待系统调度获取CPU使用权。 例： 1thread.start(); 2.3 运行状态（Running）Runnable状态的线程，根据系统调度获取到了CPU，于是执行run()方法，线程执行的代码都写在run()方法里。 2.4 阻塞状态（Blocked）线程因为某些原因，放弃了CPU使用权，暂停运行。 2.5 死亡状态（Dead）线程执行完了run()方法，或者因为异常退出了run()方法，该线程结束生命周期。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述Java中的内部类]]></title>
    <url>%2F2019%2F05%2F19%2F%E7%AE%80%E8%BF%B0Java%E4%B8%AD%E7%9A%84%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[1. 简介Java内部类分为： 成员内部类 静态内部类 方法内部类 匿名内部类 2. 成员内部类]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的表有哪些存储引擎以及区别]]></title>
    <url>%2F2019%2F05%2F19%2FMySQL%E7%9A%84%E8%A1%A8%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%BB%A5%E5%8F%8A%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. MySQL的表的存储引擎MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。这些不同的技术以及配套的相关功能在MySQL中被称作存储引擎(也称作表类型)。MySQL默认配置了许多不同的存储引擎。 常用的存储引擎有MyISAM、InnoDB、MEMORY、MERGE等。 2. MyISAM MySQL 5.x以前的默认存储引擎，使用的是表级锁。 每建立一个MyISAM存储引擎的表，都会在本地磁盘建立三个文件，比如创建了tb_demo表，则生成以下三个文件： tb_demo.frm，存储表定义。 tb_demo.MYD，存储数据。 tb_demo.MYI，存储索引。 无法处理事务。 筛选大量数据时非常迅速，这是它最突出的优点。 3. InnoDB MySQL 5.x以后的默认存储引擎，健壮的事务型存储引擎，使用行级锁。 适合处理多重并发的更新请求。 支持外键，MySQL支持外键的存储引擎只有InnoDB。 支持事务。 支持自动增加列AUTO_INCREMENT属性。 4. MEMORY 速度很快，为了得到最快的响应时间，数据存储在内存中，可以修改my.cnf配置文件中的max_heap_table_size参数来指定内存表的最大内存。 一般在以下情况使用MEMORY存储引擎： 目标数据较小，而且被非常频繁访问。 数据是临时的，而且要求立即可用。 数据如果突然消失，不会对应用服务产生实质的负面影响。 5. MERGE MERGE存储引擎是一组MyISAM表的组合，每张MyISAM表的结构必须相同（即每张表的字段顺序、字段名称、字段类型、索引定义的顺序及其定义的方式必须相同）。 MERGE表不存储数据，数据都存储在底层MyISAM表中。 每建立一个MERGE存储引擎的表，都会在本地磁盘建立两个文件，比如创建了tb_log表，则生成以下两个个文件，不会有.MYD和.MYI文件： tb_log.frm，存储表定义。 tb_log.mrg，存储底层MyISAM表的名字。 对MERGE表可以进行查询、更新、删除操作，实际是对底层MyISAM表进行操作。可以进行插入操作，但默认不允许，因为插入的数据不知道放在底层的哪张表里。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见的排序算法]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. 常见的排序算法 排序方法 平均时间复杂度 最好 最坏 空间复杂度 稳定性 冒泡排序 O(n²) O(n) O(n²) O(1) 稳定 简单选择排序 O(n²) O(n²) O(n²) O(1) 不稳定 直接插入排序 O(n²) O(n) O(n²) O(1) 稳定 希尔排序 受增量序列影响 受增量序列影响 受增量序列影响 O(1) 不稳定 快速排序 O(nlogn) O(nlogn) O(n²) O(logn)~O(n) 不稳定 稳定性：排序前后两个相等的数相对位置不变，则算法稳定。 2. 冒泡排序2.1 过程假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 从数组最后一个元素开始与前一个元素相比较，若比前一个元素小，则交换位置。 往前对每个相邻元素都进行这样比较、交换操作，最后最小的元素冒到了数组头部，成为有序部分，有序部分的元素在之后不被比较和交换。 重复前两步骤，直到全部元素有序。 2.2 Java代码实现算法代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * @ClassName: BubbleSort * @Description: 冒泡排序 * @Author: LiHaibin * @Date: 2019-05-16 10:46 * @Version: V1.0 **/public class BubbleSort &#123; /** * 从小到大的冒泡排序 * @param array */ public static void bubbleSort1(int[] array) &#123; // temp变量用于元素交换 int i, j, temp; int length = array.length; // 总共要进行length - 1轮排序 for (i = 0; i &lt; length - 1; i++) &#123; // 从最后一个元素开始比较两两比较，每轮排序要进行length - 1 - i次比较 for (j = length - 1; j &gt; i; j--) &#123; // 如果后一个元素小于前一个元素，交换这两个元素 if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; &#125; /** * 从大到小的冒泡排序 * @param array */ public static void bubbleSort2(int[] array) &#123; // temp变量用于元素交换 int i, j, temp; int length = array.length; // 总共要进行length - 1轮排序 for (i = 0; i &lt; length - 1; i++) &#123; // 从最后一个元素开始比较两两比较，每轮排序要进行length - 1 - i次比较 for (j = length - 1; j &gt; i; j--) &#123; // 如果后一个元素大于前一个元素，交换这两个元素 if (array[j] &gt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; &#125; &#125; &#125;&#125; 测试代码： 123456789101112/** * 测试冒泡排序 */@Testpublic void testBubbleSort() &#123; int[] a = &#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); BubbleSort.bubbleSort1(a); System.out.println("从小到大排序后：" + Arrays.toString(a)); BubbleSort.bubbleSort2(a); System.out.println("从大到小排序后：" + Arrays.toString(a));&#125; 2.3 算法优化可以设立flag，如果发生了交换flag设置为true，如果没有交换就设置为false。当一趟比较结束后如果flag仍为false，说明：这一趟没有发生交换，数组中的元素已经有序，没有必要继续进行下去。 优化后的算法代码： 123456789101112131415161718192021222324252627282930/** * 优化后的从小到大的冒泡排序 * @param array */public static void bubbleSort1(int[] array) &#123; // temp变量用于元素交换 int i, j, temp; // 元素是否交换的标志 boolean flag; int length = array.length; // 总共要进行length - 1趟排序 for (i = 0; i &lt; length - 1; i++) &#123; flag = false; // 每趟排序要进行length - 1 - i次比较 for (j = length - 1; j &gt; i; j--) &#123; // 如果后一个元素小于前一个元素，交换这两个元素 if (array[j] &lt; array[j - 1]) &#123; temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; flag = true; &#125; &#125; // if (!flag)即if (!flag == true) // 即flag == false，说明已经没有元素进行交换了，数组中的元素已经有序了，直接跳出循环 if (!flag) &#123; break; &#125; &#125;&#125; 3. 简单选择排序3.1 过程假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 第一个元素待定，在往后的元素中找出最小的元素，如果比第一个元素小，则交换。 第二个元素待定，在往后的元素中找出最小的元素，如果比第二个元素小，则交换。 依次进行下去，直到排序完成。 3.2 Java代码实现算法代码： 1234567891011121314151617181920212223242526272829303132/** * @ClassName: SelectSort * @Description: 简单选择排序 * @Author: LiHaibin * @Date: 2019-05-16 15:33 * @Version: V1.0 **/public class SelectSort &#123; /** * 从小到大的简单选择排序 * @param array */ public static void selectSort(int[] array) &#123; for (int i = 0; i &lt; array.length - 1; i++) &#123; // 变量minIndex用来存放最小元素下标，初始存放array[i]的下标i int minIndex = i; for (int j = i + 1; j &lt; array.length; j++) &#123; if (array[j] &lt; array[minIndex]) &#123; minIndex = j; &#125; &#125; // 如果下标与初始下标不同，则交换两个元素位置 if (minIndex != i) &#123; int temp = array[i]; array[i] = array[minIndex]; array[minIndex] = temp; &#125; &#125; &#125;&#125; 测试代码： 12345678910/** * 测试简单选择排序 */@Testpublic void testSelectSort() &#123; int[] a =&#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); SelectSort.selectSort(a); System.out.println("从小到大排序后：" + Arrays.toString(a));&#125; 4. 直接插入排序4.1 过程直接插入排序是插入排序的一种。 假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 第一个元素已经排好序，认定为有序数组。 第二个元素插到前面的有序数组中的合适位置。 第三个元素插到前面的有序数组中的合适位置。 往后元素也依次插入有序数组的合适位置，直到整个数组有序。 4.2 Java代码实现算法代码： 123456789101112131415161718192021222324252627282930313233/** * @ClassName: InsertionSort * @Description: 直接插入排序 * @Author: LiHaibin * @Date: 2019-05-16 18:17 * @Version: V1.0 **/public class InsertionSort &#123; /** * 升序的直接插入排序 * @param array */ public static void insertionSort(int[] array) &#123; // 第一轮array[0]作为已经排序好的元素 // 总共要进行array.length - 1轮的插入 for (int i =0; i &lt; array.length - 1; i++) &#123; // array[i + 1]作为将要插入的元素，依次与前面的以排序好的元素比较 for (int j = i + 1; j &gt; 0; j--) &#123; // 比前面元素小则交换位置，然后继续比较 if (array[j] &lt; array[j - 1]) &#123; int temp = array[j]; array[j] = array[j - 1]; array[j - 1] = temp; &#125; // 否则当前一轮已经有序，直接跳出循环，进行下一轮插入 else &#123; break; &#125; &#125; &#125; &#125;&#125; 测试代码： 12345678910/** * 测试插入排序 */@Testpublic void testInsertionSort() &#123; int[] a = &#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); InsertionSort.insertionSort(a); System.out.println("升序排序后：" + Arrays.toString(a));&#125; 5. 希尔排序（Shell Sort）5.1 过程希尔排序也是插入排序一种。 假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 设置第一个增量 = 数组长度 / 2，然后按增量分组，如数组{9， 2， 6， 3， 10， 5， 7， 11}，则第一个增量为4，则9、10为一组；2、5为一组；6、7为一组；3、11为一组。每组各自进行直接插入排序。 设置第二个增量 = 第一个增强 / 2，然后按增量分组，各组各自进行直接插入排序。 直到设置到增量 = 1，最后直接对整个数组进行直接插入排序。 希尔排序时间复杂度受增量序列的影响。 5.2 Java代码实现算法代码： 123456789101112131415161718192021222324252627282930313233/** * @ClassName: ShellSort * @Description: 希尔排序 * @Author: LiHaibin * @Date: 2019-05-17 14:21 * @Version: V1.0 **/public class ShellSort &#123; /** * 升序的希尔排序 * @param array */ public static void shellSort(int[] array) &#123; // 初始增量为length/2，随后再/2，直到增量为1 for (int gap = array.length / 2; gap &gt; 0; gap /= 2) &#123; // 从array[gap]开始，逐个对其所在组进行直接插入排序 for (int i = gap; i &lt; array.length; i++) &#123; // 直接插入排序 for (int j = i; j &gt;= gap; j -= gap) &#123; if (array[j] &lt; array[j - gap]) &#123; int temp = array[j - gap]; array[j - gap] = array[j]; array[j] = temp; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125;&#125; 测试代码： 12345678910/** * 测试希尔排序 */@Testpublic void testShellSort() &#123; int[] a = &#123;1, 5, 4, 88, 30, 2, 550, 12&#125;; System.out.println("排序前：" + Arrays.toString(a)); ShellSort.shellSort(a); System.out.println("升序排序后：" + Arrays.toString(a));&#125; 5. 快速排序（Quick Sort）5.1 过程假设有一个数组，放着无序的元素，我们要将元素从小到大排序。 先选择一个元素设为枢轴（pivot），一般我们选择数组第一个元素。 先从最右往左遍历，直到遇到小于枢轴的元素，交换这个元素和枢轴元素的位置。 再从左往右遍历（交换过的位置和遍历过的位置都不再遍历），直到遇到大于等于枢轴的元素，交换这个元素和枢轴元素的位置。 重复以上两步骤，直到元素都被遍历。 继续划分枢轴左右两边的数组，继续递归以上操作。 可能你还是有点迷糊，请看下面一张图，胜过千言万语： ps：以下图以数组最后一个元素设为枢轴，和我的操作稍微有点不同，但思想还是一样的。 5.2 Java代码实现算法代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * @ClassName: QuickSort * @Description: 快速排序 * @Author: LiHaibin * @Date: 2019-05-17 19:12 * @Version: V1.0 **/public class QuickSort &#123; /** * 一轮递归 * @param array * @param left * @param right */ public static int divide(int[] array, int left, int right) &#123; // 每次都将数组最左边的元素设置为枢轴（pivot） // pivot变量只是用作存储枢轴的值，用于下面比较大小 int pivot = array[left]; // left指向最左元素，right指向最右元素 while (left &lt; right) &#123; while (array[right] &gt;= pivot &amp;&amp; left &lt; right) &#123; right--; &#125; // 上面循环结束就说明当前array[right] &lt; 枢轴的值，要将数组中这两元素位置交换 if (left &lt; right) &#123; int temp = array[right]; array[right] = array[left]; array[left] = temp; // 当前left指针指向的元素及以前的元素都已经比枢轴小，所以left指针要后移一位 left++; &#125; while (array[left] &lt; pivot &amp;&amp; left &lt; right) &#123; left++; &#125; // 上面循环结束就说明当前array[left] &gt;= 枢轴的值，要将数组中这两元素位置交换 if (left &lt; right) &#123; int temp = array[left]; array[left] = array[right]; array[right] = temp; right--; &#125; &#125; // 返回left或者right都可以，因为两指针指向同一元素，即枢轴元素 return left; &#125; /** * 升序的快速排序 * @param array * @param left * @param right */ public static void quickSort(int[] array, int left, int right) &#123; if (right &gt; left) &#123; int mid = divide(array, left, right); // 继续划分枢轴左右两边的数组，继续递归下去 quickSort(array, left, mid - 1); quickSort(array, mid + 1, right); &#125; &#125;&#125; 测试代码: 12345678910/** * 测试快速排序 */@Testpublic void testQuickSort() &#123; int[] a = &#123;2, 7, 4, 5, 10, 1, 9, 3, 8, 6&#125;; System.out.println("排序前：" + Arrays.toString(a)); QuickSort.quickSort(a, 0, a.length - 1); System.out.println("升序排序后：" + Arrays.toString(a));&#125;]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述TCP和UDP的区别]]></title>
    <url>%2F2019%2F05%2F15%2F%E7%AE%80%E8%BF%B0TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. TCP和UDP是什么TCP和UDP都是TCP/IP的传输层的协议： TCP（Transmission Control Protocol），传输控制协议。 UDP（User Datagram Protocol），用户数据包协议。 1. TCP报文格式 2. UDP报文格式 3. 区别 TCP： TCP提供一种面向连接的面向字节流的服务。 TCP提供可靠交付。 TCP只能一对一连接，不提供广播或多播。 TCP对资源开销大。 UDP： UDP提供无连接的面向报文的服务。 UDP不保证可靠交付。 UDP支持一对一，一对多，多对一，多对多的交互通信。 UDP资源开销小。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述TCP三次握手和四次挥手]]></title>
    <url>%2F2019%2F05%2F14%2F%E7%AE%80%E8%BF%B0TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[1. TCP简介 TCP提供一种面向连接的、可靠的字节流服务。 每一条TCP连接只能有两个端点，是一对一的，广播和多播不能用于 TCP。 TCP提供超时重发、丢弃重复数据、校验数据、流量控制等功能。 2. TCP报文格式如图所示： TCP报文首部有几个部分重点关注： 序号字段（Sequence Number）：占32位（4字节），TCP连接中传送的数据流每一个字节都编上一个序号，序号字段的值表示本报文所发送的数据的第一个字节的序号。 确认号字段（Acknowledgement Number）：占32位（4字节），是期望收到对方下一个报文的数据的第一个字节的编号。 标志字段：共6个，URG、ACK、PSH、RST、SYN、FIN。 URG：URG=1时，表明紧急指针字段有效，此报文有紧急数据，应尽快传送。 ACK：ACK=1时，确认号字段才有效。 PSH：PSH=1时，接收方应该尽快将这个报文交给应用层。 RST：RST=1时，表明TCP连接出现严重差错，重置连接。 SYN：SYN=1时，表明这是一个连接请求（SYN）报文或者连接接受（SYN+ACK）报文。 FIN：FIN=1时，表明是FIN报文，释放连接。 3. TCP连接的建立与释放TCP的连接有三个阶段：连接建立、数据传输和连接释放。 3.1 连接建立（三次握手） 第一次握手：客户端发送一条SYN报文到服务器端，该报文SYN=1，序号（Sequence Number）=x。 第二次握手：服务器端发送一条（SYN+ACK）报文回客户端，该报文SYN=1、ACK=1，序号（Sequence Number）=y、确认号（Acknowledgement Number）=x+1。 第三次握手：客户端发送ACK报文回服务器端，该报文ACK=1，序号（Sequence Number）=x+1、确认号（Acknowledgement Number）=y+1。 此时TCP连接便已经建立，进行数据传输。 注意：发送SYN=1报文或者FIN=1报文虽然不携带数据，但仍然要消耗一个序号；ACK报文可以携带数据，如果不携带数据不消耗序号。 3.2 数据传输数据传输。 3.3 连接释放（四次挥手）客户端和服务器端双方都可以发起连接释放请求，这里假设客户端发起连接释放请求。 第一次挥手：客户端发送一条FIN报文到服务器端，该报文FIN=1，序号（Sequence Number）=u。意思是我客户端没有数据要发给你了，通知对方要释放从客户端到服务器端这个方向的连接。 第二次挥手：服务器端发送ACK报文回客户端，该报文ACK=1，序号（Sequence Number）=v，确认号（Acknowledgement Number）=u+1。此时从客户端到服务器端这个方向的连接释放，但服务器端仍然可以发送数据到客户端。 第三次挥手：服务器端发送FIN+ACK报文回客户端，该报文FIN=1、ACK=1，序号（Sequence Number）=w、确认号（Acknowledgement Number）=u+1。意思是服务器端到客户端的数据也发送完毕了，准备好释放连接了。 第四次挥手：客户端发送ACK报文回服务器端，该报文ACK=1，序号（Sequence Number）=u+1、确认号（Acknowledgement Number）=w+1。服务器端收到ACK报文后便CLOSED；而客户端进入TIME-WAIT，等待2MSL（Maximum Segment Lifetime）后如果依然没收到服务器端的ACK回复，则证明服务器端确实CLOSED，那么客户端也CLOSED。 此时TCP连接全部释放完毕。 4. 问题4.1 问题一 为什么TCP三次握手而不是两次握手？ 主要为了防止已经失效的SYN报文（连接请求报文）突然又传送到了服务器端，造成了连接的误判而使服务器资源浪费。 例： 客户端发送了SYN报文A到服务器端，但由于某些原因SYN报文A在网络上滞留了，所以客户端又超时重发了SYN报文B到服务器端，而后正常的连接建立、数据传输和连接释放。此时滞留的SYN报文A发到了服务器端，这是一个已经失效的报文，假设没有第三次握手，服务器端发送（SYN+ACK）报文回客户端后便建立了连接，但由于客户端认为自己没有发送SYN报文请求连接，所以不理会服务器端，也不传输数据给服务器端，白白造成服务器资源浪费。第三次握手就是为了避免这种情况。 4.2 问题二 TCP三次握手的缺陷？ 服务器端维护两个队列：syns queue（半连接队列）、accept queue（全连接队列）。 第一次挥手中，服务器端收到客户端的SYN报文后，就把相关信息放到半连接队列中。随后第二次挥手，服务器端发送（SYN+ACK）报文回客户端。第三次挥手服务器端收到客户端的ACK报文后，就把半连接队列里的相关信息拿出来放到全队列连接里。 SYN-Flood攻击就是攻击者伪造IP地址对服务器不停发SYN报文，而故意不理会服务器发送回的（SYN+ACK）报文，从而占满服务器的半连接队列。另一方面，真实的IP会认为我没有发送SYN报文，不理会，服务器没收到客户端的ACK报文，就不知道自己的（SYN+ACK）报文是否发送成功，一直重发，对服务器资源造成极大浪费。 4.3 问题三 为什么第四次挥手后会有TIME-WAIT状态？ 防止第四次挥手发送的ACK报文丢失（防止对方没有收到第四次挥手发送的ACK报文），所以进入TIME-WAIT状态，等待2MSL后，如果依然没收到对方发送回的ACK报文，则确定对方CLOSED，那么自己也CLOSED。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中的异常]]></title>
    <url>%2F2019%2F05%2F14%2FJava%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[1. Java中异常的结构Throwable类是所有异常的父类，它有两个子类，Error类和Exception类。 查看继承关系图： 2. Error类Error类及其子类都是程序无法处理的错误，大多数错误与代码编写者执行的操作无关，如VirtualMachineError、ThreadDeath等，这些异常发生时，只能交由JVM（Java虚拟机）处理，JVM一般会选择线程终止。 3. Exception类Exception是程序本身可以处理的异常，Exception又分为两种，一种是运行时异常，另一种是非运行时异常： 运行时异常：都是RuntimeException及其子类，如IndexOutOfBoundsException（下标越界异常）、NullPointerException（空指针异常）等，这些异常大多数是由程序逻辑错误引起，这些都是不检查异常，可以选择捕获处理，也可以不处理。 非运行时异常：RuntimeException以外的异常，是受检查异常，必须进行捕获处理，如果不进行捕获处理，编译不能通过，如常见的IOException及其子类，SQLException及其子类等，或者是自定义的异常（当然一般情况不会自定义受检查异常）。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java重载与重写]]></title>
    <url>%2F2019%2F05%2F14%2FJava%E9%87%8D%E8%BD%BD%E4%B8%8E%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[1. 重载可以理解为一个类中方法的多态，就是多个具有不同参数个数、不同参数类型的同名方法同时存在在一个类中。调用方法通过传递不同参数个数及类型来决定调用哪个方法。 2. 重写子类中一个方法与父类的某一方法有相同方法名、返回类型和参数，则子类方法覆盖原有的继承自父类的方法。这称为方法重载，需要在子类方法上添加@Override注解。如需要再用到父类方法，可用super关键字：super.方法名。 3. 区别 重载由静态类型确定，在类加载时即可确定，属于静态分派。 重写由动态类型确定，是在运行时确定的，属于动态分派。动态分派由虚方法表实现，虚方法表中存在着各个方法的实际入口地址 若子类没重写，则父类和子类的方法表中方法地址相同； 若子类重写了，则子类方法表的方法地址指向重写后的地址。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java用自定义类作为HashMap的键]]></title>
    <url>%2F2019%2F05%2F14%2FJava%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E4%BD%9C%E4%B8%BAHashMap%E7%9A%84%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Java用自定义类作为HashMap的键，在自定义类中重写哪些方法？ 必须要重写hashCode()方法和equals()方法。 自定义类中的hashCode()方法和equals()方法都继承自Object类： Object类的hashCode()方法返回这个对象存储的内存地址的哈希码。 Object类的equals()比较的是内存地址是否相等。 HashMap中进行put操作时要比较待存储的key和对应桶中的key是否相等，然后再决定将Node放到桶中的链表尾还是将新value替换旧value，key相等要满足下面两个条件： 两个key的hash值相等。（key的hash值通过hash方法得到，hash方法对key.hashCode()进行了再次运算） 两个key’==’或者’.equals’。 具体可以参考： https://fuyuanyua.github.io/2019/05/27/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3HashMap/ 现实中我们比较，例如定义了一个学生类，有学号属性，只要学号一样，即使是生成了两个对象，但我们也认为是同一个学生。所以我们判断的是逻辑上的相等，而不是内存地址上的相等，所以要重写hashCode()方法和equals()方法。 综上所述：所以要重写hashCode()方法和equals()方法。 ps：用String类型作为HashMap的键为什么没有问题呢？ 查看String类源码可发现，其实String类已经重写了hashCode()方法和equals()方法，这是JDK已经帮我们实现了的。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[char可以储存汉字吗]]></title>
    <url>%2F2019%2F05%2F13%2Fchar%E5%8F%AF%E4%BB%A5%E5%82%A8%E5%AD%98%E6%B1%89%E5%AD%97%E5%90%97%2F</url>
    <content type="text"><![CDATA[char可以储存汉字吗？ 当然可以，Java中char型变量是用来储存Unicode编码字符的，Unicode编码字符集中包含了汉字，所以可以储存汉字。Unicode编码占用两个字节，所以char类型变量也占用两个字节。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Object类中有哪些方法]]></title>
    <url>%2F2019%2F05%2F13%2FJava-Object%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java Object类中有哪些方法？ hashCode、equals、clone、toString、notify、notifyAll、wait、finalize等。 Object类源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package java.lang;/** * Class &#123;@code Object&#125; is the root of the class hierarchy. * Every class has &#123;@code Object&#125; as a superclass. All objects, * including arrays, implement the methods of this class. * * @author unascribed * @see java.lang.Class * @since JDK1.0 */public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中抽象类与接口的区别]]></title>
    <url>%2F2019%2F05%2F13%2FJava%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. 抽象类抽象类：如果一个类中有抽象方法，那么这个类就是抽象类，抽象类必须用abstract关键字修饰。 抽象方法只声明，无具体实现。 抽象类和抽象方法必须被public或protected修饰（如果是private，则不能被子类访问到，自然无法被继承也无法被子类实现抽象方法），缺省情况下默认为public。 不能用抽象类创建对象。 如果一个子类继承一个抽象类的父类，那么子类必须实现父类的所有抽象方法，如果不全部实现，这个子类任然是抽象类，必须仍然用abstract关键字修饰。 2. 接口接口：用interface定义。 接口中所有方法都必须是抽象方法，缺省被public abstract修饰，且只能被public abstract修饰。（推荐缺省即不加修饰词，使代码简洁美观）。 接口中可以有变量，缺省被public abstract final修饰，且只能被public abstract final修饰，即变量必须给初值且不可更改。一般情况下不会在接口中定义变量。 3. 抽象类和接口的区别 抽象类在Java中表示继承关系，只能单继承，class B extends A {} 接口也能继承接口，不需要实现父接口方法，且一个接口能继承多个接口，interface C extends A, B {} 一个类可以单继承，多接口实现，class E extends D implements A, B, C {} 抽象类中可以有非抽象方法，接口中必须全部为抽象方法。 抽象类中可以有static方法（static方法是类方法，不允许子类override），接口中不能有static方法，只能是public abstract方法。（这是原内容，有错误，不删，以下是正确内容） 抽象类中可以有static方法（static方法是类方法，不允许子类override）；JDK 8以后，接口中可以声明static方法，也可以声明default方法，并且都可以实现。接口中声明default方法并实现后，一个类实现该接口能自动继承该default方法，并且不用去实现（@Override）。（这是更改后的内容）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之Iterator（迭代器）]]></title>
    <url>%2F2019%2F05%2F09%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Iterator（迭代器）1.1 简介迭代器作用于集合，是用来遍历集合元素的对象。 1.2 IteratorIterator（迭代器）源自package java.util.Iterator,它是一个接口，源码如下： 12345678910111213141516public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 其中： E next()：返回迭代的下一个元素，返回值是 Object，需要强制转换成自己需要的类型。（如果使用泛型如Iterator&lt;String&gt; iterator = list.iterator()之后返回值会从Object改为指定的引用类型） boolean hasNext()：判断是否还有元素。 default void remove()：删除新返回的元素。 1.3 IterableIterable源自package java.lang.Iterable，它也是一个接口，源码如下： 123456789101112131415public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 该接口定义了方法Iterator&lt;T&gt; iterator()，返回值为迭代器对象，Collection接口继承了Iterable接口，而ArrayList、HashSet等实现类都实现了Collection接口，所以这些实现类的对象均可以.iterator()来创建Iterator对象。 以ArrayList为例查看继承关系： 1.4 以ArrayList为例演示Iterator的用法阿里巴巴Java开发手册强制规定了不要在 foreach 循环里进行元素的 remove/add 操作，remove 元素请使用 Iterator方式。 代码示例： 12345678910111213141516171819202122232425262728@Testpublic void testIterator() &#123; // 新建ArrayList对象并添加元素 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aa"); list.add("bb"); list.add("cc"); System.out.println(list); // 字符串对象，用于以下条件判断 String s = "aa"; // ArrayList对象以.iterator()来创建Iterator对象且指定了泛型为String Iterator&lt;String&gt; iterator = list.iterator(); // 判断是否还有元素 while (iterator.hasNext()) &#123; // 返回迭代的下一个元素 String item = iterator.next(); // 条件判断 if (s.equals(item)) &#123; // 移除刚返回的元素 iterator.remove(); &#125; &#125; System.out.println(list);&#125; 控制台打印信息：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Redis]]></title>
    <url>%2F2019%2F05%2F04%2FSpring-Boot%E6%95%B4%E5%90%88Redis%2F</url>
    <content type="text"><![CDATA[1. Redis简介 在实际开发中，一般使用缓存中间件：Redis、Memcached等；导入了对应的组件依赖，就可以使用对应的缓存。 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 我使用Redis作为缓存中间件。 2. 安装Redis服务和客户端2.1 Redis中文官网http://www.redis.cn/ 提供了各种对Redis的支持和参考文档以及下载，遇到问题时可以访问此网站寻求解决方法。 2.2 下载与安装 Linux版本：http://download.redis.io/releases/ Windows版本：https://github.com/MicrosoftArchive/redis/releases 我在win机上测试，下载win版，解压然后运行redis-server.exe即可。 若服务无法运行或者闪退，请参考： https://fuyuanyua.github.io/2019/04/27/redis-server-exe%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ Redis服务启动成功： 安装 Redis 可视化客户端 redis-desktop-manager-0.8.8.384.exe。 运行redis-desktop-manager。 连接Redis服务，名字任取，Host即127.0.0.1即localhost，端口号默认6379。 连接成功。 至此Redis服务与客户端已经全部安装运行完成。 3. Redis支持的数据结构3.1 常用五种数据结构 String：&lt;key, value&gt; Hash：&lt;key，fields-values&gt; List：有顺序可重复 Set：无顺序不可重复 Sorted Sets (zset) ：有顺序，不能重复 常用五种，当然还有更多数据结构请参考： http://www.redis.cn/commands.html 3.2 String：&lt;key, value&gt; set：设置key和value。 12MyRedis:0&gt;set A hello&quot;OK&quot; get：获取指定key的value。 12MyRedis:0&gt;get A&quot;hello&quot; append：追加值。 1234MyRedis:0&gt;append A world&quot;10&quot;MyRedis:0&gt;get A&quot;helloworld&quot; incr：整数值加1。 12MyRedis:0&gt;incr A&quot;ERR value is not an integer or out of range&quot; A不是整型，所以无法执行原子加1操作。 1234567891011MyRedis:0&gt;set B 1&quot;OK&quot;MyRedis:0&gt;get B&quot;1&quot;MyRedis:0&gt;incr B&quot;2&quot;MyRedis:0&gt;get B&quot;2&quot; B是整型，执行原子加1操作。 decr：整数值减1。 12345MyRedis:0&gt;decr B&quot;1&quot;MyRedis:0&gt;get B&quot;1&quot; keys *：查看所有key。 123MyRedis:0&gt;keys * 1) &quot;B&quot; 2) &quot;A&quot; del key_name：删除指定key和他对应的value。 12MyRedis:0&gt;del B&quot;1&quot; 更多语法请参考： http://www.redis.cn/commands.html#string 3.3 Hash：&lt;key，fields-values&gt;相当于一个key对于一个Map，Map中还有key-value, 使用hash对key进行归类。 hset： 12345678MyRedis:0&gt;hset myhash a1 1&quot;1&quot;MyRedis:0&gt;hset myhash a2 2&quot;1&quot;MyRedis:0&gt;hset myhash a3 3&quot;1&quot; hget： 12MyRedis:0&gt;hget myhash a2&quot;2&quot; hgetall key_name：获取指定key的hash中所有key-value。 1234567MyRedis:0&gt;hgetall myhash 1) &quot;a1&quot; 2) &quot;1&quot; 3) &quot;a2&quot; 4) &quot;2&quot; 5) &quot;a3&quot; 6) &quot;3&quot; 更多语法请参考： http://www.redis.cn/commands.html#hash 3.4 List：有顺序可重复 lpush：向左边添加值。 12MyRedis:0&gt;lpush mylist a b c d&quot;4&quot; lrange：获取指定key的list的所有值（0表示下标从0开始，-1表示获取所有）。 12345MyRedis:0&gt;lrange mylist 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; rpush：向右边添加值。 lpop：弹出左边第一个值。 rpop：弹出右边的第一个值。 12345678910111213141516MyRedis:0&gt;rpush mylist e f g&quot;7&quot;MyRedis:0&gt;lrange mylist 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;e&quot; 6) &quot;f&quot; 7) &quot;g&quot;MyRedis:0&gt;lpop mylist&quot;d&quot;MyRedis:0&gt;rpop mylist&quot;g&quot; 更多语法请参考： http://www.redis.cn/commands.html#list 3.5 Set：无顺序不可重复 sadd： 12MyRedis:0&gt;sadd myset a b c d e&quot;5&quot; smembers： 123456MyRedis:0&gt;smembers myset 1) &quot;c&quot; 2) &quot;d&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;e&quot; srem：移除指定元素 1234567MyRedis:0&gt;srem myset a&quot;1&quot;MyRedis:0&gt;smembers myset 1) &quot;d&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;e&quot; 更多语法请参考： http://www.redis.cn/commands.html#set 3.6 Sorted Sets (zset) ：有顺序，不能重复 zadd key score member：将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置，按成员得分由小到大排列。 12MyRedis:0&gt;zadd myzset 1 a 2 b 3 c&quot;3&quot; zrange： 1234567891011121314151617181920212223MyRedis:0&gt;zadd myzset 1 d 1 e&quot;2&quot;MyRedis:0&gt;zrange myzset 0 -1 1) &quot;a&quot; 2) &quot;d&quot; 3) &quot;e&quot; 4) &quot;b&quot; 5) &quot;c&quot;MyRedis:0&gt;zadd myzset 10 a&quot;0&quot;MyRedis:0&gt;zrange myzset 0 -1 withscores 1) &quot;d&quot; 2) &quot;1&quot; 3) &quot;e&quot; 4) &quot;1&quot; 5) &quot;b&quot; 6) &quot;2&quot; 7) &quot;c&quot; 8) &quot;3&quot; 9) &quot;a&quot; 10) &quot;10&quot; 更多语法请参考： http://www.redis.cn/commands.html#sorted_set]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot项目部署到云服务器]]></title>
    <url>%2F2019%2F05%2F02%2FSpring-Boot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 打包本地项目1.1 打包将本地Spring Boot项目以jar包形式打包。 IDEA最右侧栏点击Maven Projects。 找到要打包的项目，Lifecycle→package→Run Maven Build。 显示如下说明打包成功。 可在项目目录下的target目录下找到打包好的jar包。 1.2 本地测试cmd 进入jar包所在目录，运行jar包启动项目，指定80端口号，直接访问localhost或者127.0.0.1（等同于localhost）即可。 12F:\Users\Administrator\IdeaProjects\spring-boot-10-bill\target&gt;java -jar spring-boot-10-bill-0.0.1-SNAPSHOT.jar --server.port=80 2. 阿里云服务器2.1 简介阿里云官网网站：https://www.aliyun.com/ 2.2 购买先进行学生认证，然后购买仅需9.5元一个月，十分优惠。 我购买的阿里云服务器为CentOS 7.3 64位系统（什么是CentOS：https://zh.wikipedia.org/wiki/CentOS ）。 2.3 开放端口添加安全组规则，开放8080端口、80端口和3306端口。 3. 阿里云服务器安装MySQL3.1 参考安装Linux版MySQL5.7。 具体参考：https://www.jellythink.com/archives/14 4. 阿里云服务器安装JDK1.84.1 上传解压 用FileZilla（什么是FileZilla：https://themebetter.com/ftp-filezilla.html ）将 JDK安装包上传到服务器 /opt目录里面 ，右键选择上传即可。 使用secureCRT（什么是secureCRT：https://blog.csdn.net/liwf_/article/details/9429349 ）连接阿里云服务器，解压文件。 1 cd /opttar -zxvf JDK的文件名 1234 3. ls 查看解压后的JDK。4. 将JDK移动到/home目录。 mv jdk1.8.0_171/ /home/ 1234### 4.2 配置环境变量1. 用vim编辑器编辑profile文件。 vim /etc/profile 122. 在末尾行添加，打开后按i编辑, 按ctrl+c停止编辑，然后 :wq 保存退出。 export JAVA_HOME=/home/jdk1.8.0_171 export PATH=$PATH:$JAVA_HOME/bin: 123. 使更改的配置立即生效。 source /etc/profile 124. 查看JDK版本信息 java -version 12345678910111213141516 ![](QQ截图20190503163833.png) 此结果说明JDK安装配置成功。## 5. 运行### 5.1 阿里云服务器MySQL建表使用MySQL Workbench访问阿里云上的数据库，建项目所需要的表。### 5.2 设置MySQL开机自启动使用secureCRT设置阿里云服务器上MySQL开机自启动。 chkconfig mysqld on123456### 5.3 运行项目- 先用FileZilla将本地打包好的项目jar包推送到阿里云服务器。- 然后用secureCRT在阿里云服务器上以后台进程并用80端口运行项目。 nohup java -jar 项目jar包名 –servre.port=80 &amp; 123456789101112- 至此已经将项目在阿里云服务器全部部署完成，理论上访问阿里云服务器的IP地址，便可以成功访问本项目。### 5.4 一些小问题- Linux下MySQL中文乱码（全部显示问号）， 请参考：https://blog.csdn.net/leen0304/article/details/80534609- 网页响应特别慢， 请参考：https://www.cnblogs.com/zhangyuejia/p/8575080.html]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的常用命令]]></title>
    <url>%2F2019%2F05%2F02%2FLinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. Linux的常用命令 进入指定目录，cd即change directory的缩写。 1# cd /xx/xx 进入用户主目录，即HOME变量指定的目录，如root用户的主目录为/root。 1# cd ~ 或 1# cd 返回上一级目录。 1# cd .. 查看当前目录下所有文件。 1# ls 解压压缩包到当前目录下（按Tab键可以快速补全文件名）。 1# tar -zxvf 文件名 移动指定文件或目录到指定目录下。 1# mv /xx/xx /xx/xx 用vim编辑器编辑指定文件。 1# vim /xx/xx 进入文件后： 按i：切换到输入模式，以输入字符。 按ctrl+c：暂停。 暂停后： 按:w：保存文件但不退出vim。 按:wq：保存文件并退出vim。 按:q：不保存文件，退出vim。 按:q!：不保存文件，并强制退出vim。 重新执行刚修改的初始化文件，使之立即生效。 1# source 文件名 启动以jar包形式打包的java项目。 1# java -jar 项目jar包名 以80端口启动jar包形式的java项目。 1# java -jar 项目jar包名 --servre.port=80 以后台进程运行项目。 1# nohup java -jar 项目jar包名 --servre.port=80 &amp; 查看所有java进程。 1# ps -ef|grep java 停止所有java进程。 1# pkill -9 java 停止指定java进程。 1# kill -9 java进程序号 连接本地主机mysql。 1# mysql -u 用户名 -p 密码 一般都是： 1# mysql -u root -p 随后输入密码即可进入mysql。 连接远程主机mysql。 1# mysql -h 远程主机IP地址 -u 用户名 -p 密码 查看当前Linux系统内核版本 1# uname -r]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-server.exe启动失败解决方案]]></title>
    <url>%2F2019%2F04%2F27%2Fredis-server-exe%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天我下载了Win版的Redis，解压缩后，双击redis-server.exe，屏幕一闪而过，启动失败，查阅网上资料后找到解决办法。 win+R打开cmd命令。 进入F盘：f: cd到Redis包目录下：cd F:\redis\Redis-x64-3.2.100（在当前目录的地址栏直接输入cmd，可直接进入，更方便） 输入：redis-server.exe redis.windows.conf 启动成功]]></content>
      <categories>
        <category>小坑</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot缓存操作]]></title>
    <url>%2F2019%2F04%2F25%2FSpring-Boot%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 缓存1.1 简介在开发中，如果有经常频繁访问的数据，那么一般都使用缓存，以此来减少访问数据库，减轻压力。 1.2 引入缓存启动器依赖pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 1.3 application.yml全局配置文件创建数据库bill并在user表中添加几条数据。 然后配置application.yml： 12345678910111213141516spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/bill?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver# com.example.springboot.mapper.UserMapper包下打印日志级别为debuglogging: level: com.example.springboot.mapper.UserMapper: debug# 开启自动驼峰命名方式mybatis: configuration: map-underscore-to-camel-case: true 1.4 @EnableCaching注解在启动类上使用注解@EnableCaching以开启注解版缓存。 12345678910@EnableCaching //开启注解版缓存@MapperScan("com.example.springboot.mapper")@SpringBootApplicationpublic class SpringBoot13CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot13CacheApplication.class, args); &#125;&#125; 1.5 @Cacheable注解@Cacheable注解标注在方法上（一般写在Service层），该方法的返回结果就会进行缓存。 把缓存理解为一个“缓存容器”，里面有一条条key，每个key对应的value为方法返回的值。 @Cacheable的属性： cacheNames指定“缓存容器”的名字。 key指定缓存中的key值，key = &quot;#id&quot;即将方法中的参数id当做key。 Service层中代码示例： 1234567891011/** * cacheNames：缓存容器名字 * key：缓存容器中的key值，方法返回值为value值 * @param id * @return */@Cacheable(cacheNames = "user", key = "#id")public User getUserById(Integer id) &#123; User user = userMapper.getUserById(id); return user;&#125; 1.6 @CachePut注解@CachePut注解保证了修改了表中的数据后，同时更新缓存中的数据，使得别人查询这条已更新的数据直接从缓存中获取。 测试： 先查询id=1的用户，数据会放在缓存中。 后面查询id=1的用户数据都从缓存中获取。 更新id=1的用户，同时会更新缓存中的数据。 后面查询id=1的用户数据依然直接从缓存中获取。 Service层中代码示例： 1234567@CachePut(cacheNames = "user", key = "#user.id")//cacheNames = "user" 必须指定一个缓存的名称，不然报500错误//缓存都是在调用方法之后执行，而不是调用方法之前执行public User updateUser(User user) &#123; userMapper.updateUser(user); return user;&#125; 1.7 @CacheEvict注解默认情况下删除数据不会将缓存中的数据删除，使用@CacheEvict注解，使得删除数据的同时也将缓存中的数据删除。 @CacheEvict的属性： cacheNames指定“缓存容器”的名字。 key指定缓存中的key值，key = &quot;#id&quot;即将方法中的参数id当做key。 allEntries = true 会将缓存中所有数据清除，默认false。 beforeInvocation = true 在调用方法之前清理缓存，默认false（在调用方法之后再清理缓存）。 Service层中代码示例： 123456789101112/** * 默认情况下删除数据不会将缓存中的数据删除 * allEntries = true 会将缓存中所有数据清除，默认false * beforeInvocation = true 在调用方法之前清理缓存，默认false（在调用方法之后再清理缓存） * @param id * @return */@CacheEvict(cacheNames = "user", key = "#id", allEntries = true, beforeInvocation = true)public Integer deleteUserById(Integer id) &#123; userMapper.deleteUserById(id); return id;&#125; 1.8 @CacheConfig注解@CacheConfig(cacheNames = &quot;user&quot;)配置了该类下所有方法的缓存名都为”user”，这样就不用在下面每个方法的注解上指定cacheNames = &quot;user&quot;了。 代码示例： 1234567891011121314151617181920@CacheConfig(cacheNames = "user")//此注解配置了类下所有方法缓存名都为"user",就不用在下面每个方法的注解上指定cacheNames = "user"了@Servicepublic class UserService &#123; @Autowired UserMapper userMapper; /** * cacheNames：缓存容器名字 * key：缓存容器中的key值，方法返回值为value值 * @param id * @return */ @Cacheable(/*cacheNames = "user",*/ key = "#id") public User getUserById(Integer id) &#123; User user = userMapper.getUserById(id); return user; &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.04.21-23上海旅行规划]]></title>
    <url>%2F2019%2F04%2F20%2F2019-04-21-23%E4%B8%8A%E6%B5%B7%E6%97%85%E8%A1%8C%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[2019.04.21上午： 宁波（09:54）——上海虹桥（12:10） 中午： 午餐 富贵面馆 牛蛙面 安顺路175号 地铁10号线（虹桥火车站上，虹桥路下） 下午： 上海当代艺术博物馆 门票20元起 黄浦区苗江路678号 地铁4号线外圈（虹桥路上，西藏南路下） INVINCIBLE 鞋店 SOHO复兴广场，马当路388号103 地铁8号线（西藏南路上，老西门下），地铁10号线（老西门上，新天地下） CONCEPTS 鞋店 上海新天地，兴业路123弄2 步行 DOE 鞋店 黄浦区湖滨路168号 步行 晚餐 SHAKE SHACK 汉堡 上海新天地，太仓路181弄10号 步行 晚上： 南京东路 上海001，南京路步行街，外滩，上海市人民英雄纪念塔 地铁1号线（黄陂南路上，人民广场下） 回家 徐汇区复兴中路1218弄 地铁10号线（南京东路上，陕西南路下） 2019.04.22上午： 早餐 暂定 甜爱路 甜爱路，鲁迅纪念馆，多伦路文化名人街 地铁1号线（陕西南路上，人民广场下），地铁8号线（人民广场上，虹口足球场下） 中午： 午餐 蟹黄鱼 黄浦区太仓路200号一层B区 地铁8号线（虹口足球场上，人民广场下），地铁1号线（人民广场上，黄陂南路下） 下午： 武康路 武康大楼，巴金故居，法租界 地铁1号线（黄陂南路上，陕西南路下），地铁10号线（陕西南路上，交通大学下） JUICE SH 鞋店 静安区巨鹿路832号 步行或骑车 暂定 暂定 暂定 暂定 晚餐 暂定 暂定 暂定 晚上： Troye Sivan演唱会 开始时间（20:00） 上海梅赛德斯奔驰文化中心 视情况而定 暂定可选 哈灵面馆（牛蛙面） 鲜得来（排骨年糕） 红宝石（奶油小方，栗子蛋糕） 平成屋日料]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot邮件操作]]></title>
    <url>%2F2019%2F04%2F19%2FSpring-Boot%E9%82%AE%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 简单邮件1.1 引入邮件依赖新建项目时在引入依赖时勾选I/O中的Mail选项，项目创建好后查看pom.xml文件有此依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 配置application.yml文件以qq邮箱为例， spring.mail.username为邮箱名，已打码。 spring.mail.password为授权第三方登录的密码。 设置发送邮件的服务器。 设置SSL连接为true。 123456789# 配置邮箱信息spring: mail: username: xxxxxxxxx@qq.com password: sroomflkeutvbbfj # 发送邮件服务器 host: smtp.qq.com # SSL连接 properties.smtp.ssl.enable: true 1.3 测试类 @Autowired JavaMailSenderImpl javaMailSender;注入JavaMailSenderImpl。 SimpleMailMessage类 封装了简单邮件。 simpleMailMessage.setFrom()发送方邮箱，已打码。 simpleMailMessage.setTo()接收方邮箱，已打码。 1234567891011121314151617181920212223@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot12MailApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; //简单邮件测试 @Test public void testSimpleMail() &#123; //SimpleMailMessage类，封装简单邮件 SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); //设置邮件主题（标题） simpleMailMessage.setSubject("标题测试"); //设置邮件正文 simpleMailMessage.setText("正文测试"); //设置发件人 simpleMailMessage.setFrom("xxxxxxxxx@qq.com"); //设置收件人 simpleMailMessage.setTo("xxxxxxxxx@gmail.com"); javaMailSender.send(simpleMailMessage); &#125;&#125; 1.4 运行接收方邮箱便能收到这份简单邮件。 2. 复杂邮件2.1 引入邮件依赖同1.1，略。 2.2 配置application.yml文件同1.2，略。 2.3 测试类 MimeMessage类的对象不能直接设置标题正文等发送内容。 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);需要通过MimeMessageHelper类的对象来设置发送内容。 mimeMessageHelper.setText()第二个参数设置为true，才能使用html代码。 mimeMessageHelper.addAttachment()设置附件，第一个参数指定附件名。 1234567891011121314151617181920212223242526@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot12MailApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; //复杂邮件测试 @Test public void testMimeMail() throws MessagingException &#123; //MimeMessage类 MimeMessage mimeMessage = javaMailSender.createMimeMessage(); //通过MimeMessage帮助对象 来设置发送内容，第二个参数为true表示可以发送附件 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); //设置邮件主题（标题） mimeMessageHelper.setSubject("标题测试1"); //设置邮件正文,第二个参数设置为true，才可以发送html代码 mimeMessageHelper.setText("&lt;h2 style='color:red'&gt;正文测试2&lt;/h2&gt;", true); mimeMessageHelper.addAttachment("1.jpg", new File("D:\\用户目录\\我的图片\\02_CONVERSEXMDNS_LANDINGPAGE_20181007_01.jpg")); //设置发件人 mimeMessageHelper.setFrom("xxxxxxxxx@qq.com"); //设置收件人 mimeMessageHelper.setTo("xxxxxxxxx@gmail.com"); javaMailSender.send(mimeMessage); &#125;&#125; 2.4 运行接收方邮箱便能收到邮件，且邮件带有一份名为1.jpg的附件。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot异步任务和定时任务]]></title>
    <url>%2F2019%2F04%2F17%2FSpring-Boot%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 异步任务1.1 简介项目开发中，绝大多数情况是通过同步方式处理业务逻辑，但批量处理数据，批量发送邮件等容易造成阻塞，之前都是通过使用多线程来完成此类任务。 在Spring 3+后内置了@Async注解来解决此类问题，提高效率。 1.2 启动类上使用@EnableAsync注解在启动类上使用@EnableAsync注解，开启基于注解版的异步处理。 代码示例： 123456789@EnableAsync //开启基于注解版的异步处理@SpringBootApplicationpublic class SpringBoot11TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot11TaskApplication.class, args); &#125;&#125; 1.3 在方法上使用@Async注解在方法上标识@Async注解，该方法就会基于异步处理。 代码示例： 1234567891011121314@Servicepublic class AsyncService &#123; @Async //在该方法上标识注解，该方法就会基于异步处理 public void batchAdd() &#123; try &#123; //模拟新增数据 Thread.sleep(3*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("批量新增数据完成"); &#125;&#125; 2. 定时任务2.1 简介在项目开发中，经常要执行一些定时任务。 2.2 启动类上使用@EnableScheduling注解在启动类上使用@EnableScheduling注解，开启注解版的定时任务。 代码示例： 123456789@EnableScheduling //开启注解版的定时任务@SpringBootApplicationpublic class SpringBoot11TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot11TaskApplication.class, args); &#125;&#125; 2.3 在方法上使用@Scheduled注解代码示例： 123456789101112131415@Servicepublic class ScheduledService &#123; private static int count = 1; /** * on the second(秒) as well as minute(分), hour(时), day(天) of month, month(月) and day of week(星期). * &lt;p&gt;E.g. &#123;@code "0 * * * * MON-FRI"&#125; means once per minute on weekdays 表示在工作日（周一到周五）每分钟执行一次 */ //cron = "*/3 * * * * MON-FRI"表示在周一到周五每三秒执行一次 @Scheduled(cron = "*/3 * * * * MON-FRI") public void dataCount() &#123; System.out.println("数据统计第" + count++ + "次"); &#125;&#125; 2.3 @Scheduled详解 @Scheduled(cron = &quot;*/3 * * * * MON-FRI&quot;)：通过cron表达式定义规则。 cron表达式自动生成网站： http://cron.qqe2.com/ 从左到右依次 取值范围 可指定的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * / ? L W C 月份 1-12 , - * / 星期 0-7或MON-SUN（0和7都代表周日，1-6代表周一到周六） , - * / ? L C # @Scheduled(fixedRate = 3000):上一次开始执行时间点之后3秒再执行。 @Scheduled(fixedDelay = 3000)：上一次执行完毕时间点之后3秒再执行。 @Scheduled(initialDelay=1000, fixedRate=3000)：第一次延迟1秒后执行，之后按fixedRate的规则每3秒执行一次。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>异步任务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合MyBatis]]></title>
    <url>%2F2019%2F04%2F10%2FSpring-Boot%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[1. Spring Boot整合MyBatis配置文件版1.1 建表使用MySQL数据库，新建一个名为“mybatis”的schema，分别建“bill“、”provider“和”user“表并添加数据。 1.2 application.yml全局配置文件12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 1.3 创建实体类在 com.example.springboot.entities 包下创建Provider实体类和Bill实体类。 Provider类： 为减少篇幅，这里只给出成员变量，有参、无参构造方法，get，set，toString方法均省略。 123456789101112131415161718192021public class Provider &#123; private Integer pid; //供应商编码 private String providerCode; //供应商名称 private String providerName; //联系人 private String people; //联系电话 private String phone; //联系地址 private String address; //传真 private String fax; //描述 private String describe; // 创建时间 private Date createDate; 其余代码省略。。。&#125; Bill类： 为减少篇幅，这里只给出成员变量，有参、无参构造方法，get，set，toString方法均省略。 12345678910111213141516171819202122public class Bill &#123; private Integer bid; // 账单编码 private String billCode; // 商品名称 private String billName; // 商品单位 private String billCom; // 商品数量 private Integer billNum; // 总金额 private Double money; // 供应商 private Provider provider; // 是否付款 0 未付款， 1已付款 private Integer pay; // 创建时间 private Date createDate; 其余代码省略。。。&#125; 1.4 创建Mapper接口在 com.example.springboot.mapper 包下创建 BillMapper 接口： 可在各Mapper接口上使用@Mapper注解，表明这是一个Mapper接口。 也可在启动类上直接使用注解@MapperScan(&quot;com.example.springboot.mapper&quot;)，便能扫描该包下的所有Mapper自动装到容器当中，而不用在各Mapper上加上注解@Mapper。 代码示例： BillMapper接口： 12345678910111213141516/** * 使用MyBatis配置文件版 *///@Mapper 或者在启动类上使用注解 @MapperScan("com.example.springboot.mapper")public interface BillMapper &#123; //接口方法默认被public修饰 Bill getBillByBid(Integer bid); int addBill(Bill bill); int updateBill(Bill bill); int deleteBill(Integer bid);&#125; 启动类： 12345678910@MapperScan("com.example.springboot.mapper")//扫描该包下的所有Mapper自动装到容器当中，而不用在各Mapper上加上注解@Mapper@SpringBootApplicationpublic class SpringBoot08DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataMybatisApplication.class, args); &#125;&#125; 1.5 创建MyBatis核心配置文件在resources目录下新建mybatis目录，在该目录下创建mybatis-config.xml，这便是MyBatis核心配置文件，我在这仅仅配置了开启自动驼峰命名规则映射，文件编写参考官方文档：http://www.mybatis.org/mybatis-3/zh/getting-started.html 代码示例： 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 这是mybatis核心配置文件 --&gt; &lt;settings&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射， 即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 1.6 创建Mapper映射配置文件在resources目录的mybatis目录下新建mapper目录，在该目录下创建BillMapper.xml，在此文件中编写sql语句，文件编写也参考官网文档：http://www.mybatis.org/mybatis-3/zh/getting-started.html 代码示例： 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.springboot.mapper.BillMapper"&gt; &lt;select id="getBillByBid" resultType="com.example.springboot.entities.Bill"&gt; select * from bill where bid = #&#123;bid&#125; &lt;/select&gt; &lt;insert id="addBill"&gt; insert into bill(bill_code, bill_name, bill_com, bill_num) values (#&#123;billCode&#125;, #&#123;billName&#125;, #&#123;billCom&#125;, #&#123;billNum&#125;) &lt;/insert&gt;&lt;/mapper&gt; &lt;mapper namespace=&quot;com.example.springboot.mapper.BillMapper&quot;&gt;定义了对应接口BillMapper的路径。 以查询为例，select id=&quot;getBillByBid&quot;，getBillByBid与接口中的方法Bill getBillByBid(Integer bid);对应，resultType=&quot;com.example.springboot.entities.Bill&quot;则是方法返回值的实体类Bill的路径。 #{}用于表示一个占位符，相当于?，而#{bid}则表示该占位符待接收参数的名称为bid。 1.7 重新配置application.yml全局配置文件1234567891011121314151617181920212223242526272829303132333435spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# mybatis配置文件版，配置相关文件路径mybatis: # 映射文件路径 mapper-locations: classpath:mybatis/mapper/*.xml # mybatis核心配置文件路径 config-location: classpath:mybatis/mybatis-config.xml classpath:表示类路径，在Spring Boot项目里等同于resources目录，在其他项目也可等同于res目录。 *.xml表示该目录下所有.xml文件。 1.8 创建控制层在com.example.springboot.controller包下新建类BillController： 123456789101112131415161718@RestControllerpublic class BillController &#123; @Autowired BillMapper billMapper; @GetMapping("/bill/&#123;bid&#125;") public Bill getBillByBid(@PathVariable("bid") Integer bid) &#123; Bill bill = billMapper.getBillByBid(bid); return bill; &#125; @GetMapping("/bill") public Bill addBill(Bill bill) &#123; int i = billMapper.addBill(bill); return bill; &#125;&#125; @RestController注解等同于@Controller+@ResponseBody这两个注解合在一起的作用，表示不返回jsp或html页面，直接返回return的内容。 @Autowired BillMapper billMapper; 表示直接将BillMapper接口注入。 1.9 测试启动启动类SpringBoot08DataMybatisApplication，在浏览器输入：http://localhost:8080/bill/1 效果显示： 数据库中bill表： 网页中数据与数据库中均一一对应，表明成功。 2. Spring Boot整合MyBatis注解版2.1 建表同1.1，表已经建好。 2.2 application.yml全局配置文件12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 2.3 创建实体类同1.3，实体类均已创建好。 2.4 创建Mapper接口在 com.example.springboot.mapper 包下创建 ProviderMapper 接口。 代码示例： ProviderMapper接口： 123456789101112131415161718192021222324/** * 使用mybatis注解版 */@Mapper //这是指定操作数据的Mapperpublic interface ProviderMapper &#123; //接口默认public修饰 //查 @Select("select * from provider where pid = #&#123;pid&#125;") Provider getProviderByPid(Integer pid); //增 @Insert("insert into provider(providerName) values (#&#123;providerName&#125;)") int addProvider(Provider provider); //删 @Delete("delete from provider where pid = #&#123;pid&#125;") int deleteProviderByPid(Integer pid); //改 @Update("update provider set providerName = #&#123;providerName&#125;") int updateProvider(Provider provider);&#125; 启动类： 12345678@SpringBootApplicationpublic class SpringBoot08DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataMybatisApplication.class, args); &#125;&#125; 2.5 创建控制层在 com.example.springboot.controller 包下创建ProviderController类。 代码示例： 123456789101112@RestControllerpublic class ProviderController &#123; @Autowired ProviderMapper providerMapper; @GetMapping("/provider/&#123;pid&#125;") public Provider getProvider(@PathVariable("pid") Integer pid) &#123; Provider provider = providerMapper.getProviderByPid(pid); return provider; &#125;&#125; 2.6 创建MyBatis配置类因为MyBatis注解版没有xml配置文件，所以需要使用配置类来配置，我在 com.example.springboot.config 包下创建MyBatisConfig类，主要配置了开启了自动驼峰命名规则映射。 代码示例： 12345678910111213141516@Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer ConfigurationCustomizer() &#123; ConfigurationCustomizer configurationCustomizer = new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; //是否开启自动驼峰命名规则（camel case）映射， // 即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; return configurationCustomizer; &#125;&#125; 2.7 测试启动启动类SpringBoot08DataMybatisApplication，在浏览器输入：http://localhost:8080/provider/1 网页效果： 数据表： 测试成功。 3. 心得无论Mybatis注解版还是配置文件版，都能实现相同功能，所以都需要掌握。 但是本人更倾向于配置文件版，因为如果遇到复杂的sql语句，写在注解上让代码显得特别繁琐复杂，而单独写在mapper映射文件中则显得简洁许多。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>MySQL</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot事务管理]]></title>
    <url>%2F2019%2F04%2F09%2FSpring-Boot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 事务管理1.1 简介事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。在Spring Boot中，使用了spring-boot-starter-jdbc或者spring-boot-starter-data-jpa依赖时，框架会自动默认注入DataSourceTransactionManager或者jpaTransactionManager。所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。 1.2 事务管理步骤 在启动类中，使用@EnableTransactionManagement开启注解方式事务管理支持。 123456789@EnableTransactionManagement //开启注解方式事务支持@SpringBootApplicationpublic class SpringBoot08DataJpaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataJpaApplication.class, args); &#125;&#125; 在Service层方法上使用@Transactional注解。 @Transactional也可直接注解在类上，这样默认该类下所有方法都开启事务注解。 但实际中一般只对 增、删、改 进行事务管理，不对 查 进行事务管理，所以注解在方法上。 1.3 注意 application.yml配置文件 1234567891011121314spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/jpa?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关配置 jpa: hibernate: # 会根据映射实体类自动创建会更新数据表 ddl-auto: update # 控制台打印sql语句 show-sql: true 如果使用 JPA（Java Persistence API），hibernate在自动创建表时，创建的表引擎是 MyISAM，是非事务安全的，无法实现事务回滚。需要指定 InnoDB 引擎才可以进行事务管理。 在application.yml配置文件中添加配置 12345678910111213141516spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/jpa?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关配置 jpa: hibernate: # 会根据映射实体类自动创建会更新数据表 ddl-auto: update # 控制台打印sql语句 show-sql: true # 指定表的引擎为InnoDB，如果不指定，则默认表引擎为MyISAM,MyISAM是不支持事务管理的 database-platform: org.hibernate.dialect.MySQL57Dialect 2. 事务的隔离级别2.1 脏读、不可重复读和幻读 脏读：A事务执行过程中修改了id=1的数据，未提交前，B事务读取了A事务修改的id=1的数据，而这时A事务却回滚了，这样B事务就形成了脏读。 不可重复读：A事务先读取了一条数据，然后执行逻辑，这时B事务将这条数据改变了，然后A事务再次读取这条数据，发现数据不匹配了，这就是不可重复读。 幻读：A事务先根据条件查询到了N调数据，然后这时B事务新增了M条符合A事务查询条件的数据，A事务再次查询时发现有N+M条数据了，就产生了幻读。 2.2 隔离级别数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。 隔离级别 脏读 不可重复读 幻读 Read uncommitted（读未提交） √ √ √ Read committed（读提交） × √ √ Repeatable read（重复读） × × √ Serializable（序列化） × × × 2.3 源码查看org.springframework.transaction.annotation包中的枚举类Isolation定义了五个表示隔离级别的值： 12345678910111213141516171819package org.springframework.transaction.annotation;public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8); private final int value; private Isolation(int value) &#123; this.value = value; &#125; public int value() &#123; return this.value; &#125;&#125; DEFAULT：默认值，表示使用底层数据库的默认隔离级别，大多数数据库的默认隔离级别是READ_COMMITTED。 READ_UNCOMMITTED：通常很少使用该隔离级别，因为避免不了脏读、不可重复读和幻读。 READ_COMMITTED：可以防止脏读，也是大多数数据库的默认隔离级别，比如SQL Server , Oracle，性能最好。 REPEATABLE_READ：可以避免脏读和不可重复读，是MySQL的默认隔离级别。 SERIALIZABLE：可以避免脏读、不可重复读和幻读，但严重影响程序性能，通常不会用到该级别。 2.4 指定隔离级别在@Transactional注解上设置属性： 123@Transactional(isolation = Isolation.DEFAULT) //当前方法开启事务管理 //isolation指定隔离级别，当前指定为默认 3. 事务的传播行为3.1 源码查看org.springframework.transaction.annotation包中的枚举类Propagation定义了七个表示传播行为的值： 123456789101112131415161718192021package org.springframework.transaction.annotation;public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6); private final int value; private Propagation(int value) &#123; this.value = value; &#125; public int value() &#123; return this.value; &#125;&#125; REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。如果A方法有事务，那么B方法就使用A方法的事务。如果A方法没有事务，那么B方法就创建一个新事物。是Spring提供的默认事务传播行为，适合绝大数情况。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。如果A方法有事务，那么B方法就使用A方法的事务。如果A方法没有事务，那么B方法就不使用事务的方式执行 MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。如果A方法有事务，那么A方法就使用A方法事务。如果A方法没有事务，那么就抛出异常。该事务传播行为要求A方法必须以事务的方式运行。 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。如果A方法有事务，就把A方法的事务挂起，B方法新创建一个事务。如果A方法没有事务，那么B方法就创建一个新事务。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。如果A方法有事务，那么就把A方法的事务挂起，B方法以非事务的方式执行。如果A方法没有事务，那么B也不使用事务执行。 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。如果方法A有事务，那么就抛出异常。如果方法A没有事务，那么B方法就以非事务的方式运行。 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的。如果A方法有事务，那么B方法就在A方法的事务中使用嵌套事务。如果A方法没有事务，那么方法B就新创建一个事务。 3.2 指定传播行为在@Transactional注解上设置属性： 1234@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED )//当前方法开启事务管理//isolation指定隔离级别，当前指定为默认//propagation指定传播行为，当前指定为默认]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Druid数据源]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%85%8D%E7%BD%AEDruid%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[1. 配置Druid数据源什么是数据源？ 参考：https://www.cnblogs.com/aspirant/p/6747238.html Spring Boot 2.0 默认使用 HikariCP 作为数据源。 Druid 是阿里巴巴推出的国产数据库连接池，据网上测试对比，比目前的 DBCP 或 C3P0 数据库连接池性能更好，并且 Druid 能够提供强大的监控和扩展功能。 1.1 在pom.xml中引入依赖123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt; 1.2 在全局配置文件application.yml中配置12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/jdbc?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 1.3 绑定Druid相关信息在config目录下新建类DruidConfig 123456789@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid() &#123; return new DruidDataSource(); &#125;&#125; 至此Druid数据库连接池配置完毕。 2. 配置Druid的监控Druid 自带监控管理系统，要配置一个Druid监控： 配置一个Druid的Servlet 配置一个Druid的Filter 完成 2.1 配置一个Druid的Servlet在config目录下DruidConfig类下: 1234567891011121314151617//配置一个Druid的后台管理系统的Servlet@Beanpublic ServletRegistrationBean statViewServlet() &#123; //请求是/druid/* ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), "/druid/*"); //设置初始化参数值 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(StatViewServlet.PARAM_NAME_USERNAME, "root"); map.put(StatViewServlet.PARAM_NAME_PASSWORD, "123456"); //如果不写，则默认所有IP地址都可以访问 map.put(StatViewServlet.PARAM_NAME_ALLOW, ""); //指定IP地址禁止访问 map.put(StatViewServlet.PARAM_NAME_DENY, "192.168.1.1"); bean.setInitParameters(map); return bean;&#125; 2.2 配置一个Druid的Filter在config目录下DruidConfig类下: 123456789101112131415//配置一个Druid的Filter@Beanpublic FilterRegistrationBean webStatFilter() &#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); //设置不拦截的请求 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, "*.js, *.css, /druid/*"); bean.setInitParameters(map); //设置拦截请求, /* 表示拦截所有请求 bean.setUrlPatterns(Arrays.asList("/*")); return bean;&#125;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot嵌入式Servlet容器]]></title>
    <url>%2F2019%2F04%2F03%2FSpring-Boot%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 修改Servlet配置参考pom.xml文件可以知道，Spring Boot默认使用Tomcat作为嵌入式的Servlet容器。 1.1 通过全局配置文件修改Servlet配置通过修改全局配置文件application.properties，修改嵌入式Servlet容器配置： 12345678910# 修改关于服务的相关配置，对应的类是ServerProperties# 修改端口号server.port=8081# 修改Servlet的相关配置，修改应用名server.servlet.context-path=/servlet# 修改Tomcat的相关配置server.tomcat.max-connections=80000 1.2 通过自定义配置器修改Servlet配置Spring Boot 2.x： 实现WebServerFactoryCustomizer接口的customize抽象方法： 123456789101112131415161718/** * 自定义定制器修改Servlet容器配置 */@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; //采用匿名内部类实现WebServerFactoryCustomizer接口的void customize(T factory)抽象方法 return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; ConfigurableServletWebServerFactory factory1 = (ConfigurableServletWebServerFactory) factory; //修改端口号，如果全局配置文件中的配置与定制器的配置冲突，默认采用定制器的配置 factory1.setPort(8082); //修改应用名 factory1.setContextPath("/servlet2"); &#125; &#125;;&#125; 2. 切换为其他嵌入式Servlet容器Spring Boot默认针对Servlet容器提供以下支持： Tomcat（默认使用）。 Jetty：支持长连接项目（如：聊天页面）。 Undertow：不支持jsp，但是并发性能高，是高性能非阻塞的容器。 2.1 使用Jetty 在pom.xml文件中移除Tomcat 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 移除Tomcat启动器 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入Jetty依赖 12345&lt;!-- 引入Jetty启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 使用Undertow 在pom,xml文件中移除Tomcat，代码同上。 引入Undertow依赖 12345&lt;!-- 引入Undertow启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中pom文件的依赖配置]]></title>
    <url>%2F2019%2F04%2F02%2FSpring-Boot%E4%B8%ADpom%E6%96%87%E4%BB%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. pom.xml文件中依赖配置Spring Boot中需要使用什么，只需在pom.xml文件中引入相对应的依赖即可，以下来介绍各种依赖。 1.1 thymeleaf模板启动器12345&lt;!-- 引入thymeleaf模板启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 注释处理器123456&lt;!-- 该依赖为注释处理器，在编写配置文件时能自动提示自定义的类 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 1.3 热部署12345&lt;!-- 热部署依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 1.4 jquery webjars123456&lt;!-- 引入jquery webjars --&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-2&lt;/version&gt;&lt;/dependency&gt; 1.5 Druid数据库连接池1234567&lt;!-- Druid数据库连接池 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt; 1.6 MyBatis123456&lt;!-- MyBatis启动器，已经引入了spring-boot-starter-jdbc启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 1.7 JDBC1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 1.8 Java连接MySQL驱动包123456&lt;!-- Java连接MySQL驱动包 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot实现热部署]]></title>
    <url>%2F2019%2F04%2F02%2FSpring-Boot%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[1. Spring Boot实现项目的热部署1.1 简介Spring Boot项目的热部署，按照我的理解，就是在修改代码后，无须重新启动服务器，只需要重新Build Project，然后刷新网页，就可以立即在网页查看到修改后的变化。 1.2 在配置文件中禁用模板缓存如果不禁用缓存，那么因为有网页的缓存，变化无法实时获取，所以在配置文件application.properties或者application,yml中禁用Thymeleaf模板缓存，下面以application.properties配置文件为例： 12# 开发中推荐关闭thymeleaf的缓存，可以实现热部署spring.thymeleaf.cache=false 1.3 在pom.xml文件中引入依赖在pom.xml文件中引入热部署依赖： 12345&lt;!-- 热部署依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 1.4 实现按IDEA快捷键 ctrl+F9 进行Build Project，无须重新启动服务器，然后刷新网页即可实现项目的热部署。]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Thymeleaf（二）]]></title>
    <url>%2F2019%2F03%2F31%2FSpring-Boot%E6%95%B4%E5%90%88Thymeleaf%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 声明公共代码片段1.1 简介有两种方式声明公共代码片段： 通过th:fragment声明公共代码片段。 通过id选择器声明公共代码片段。 1.2 通过th:fragment声明示例： 123456&lt;!-- 通过th:fragment声明公共代码片段 --&gt;&lt;div th:fragment="header_common"&gt; &lt;p&gt; 文字内容 &lt;/p&gt;&lt;/div&gt; 1.3 通过id选择器声明示例： 123456&lt;!-- 通过id选择器进行声明公共代码片段 --&gt;&lt;div id="header_common_id"&gt; &lt;p&gt; 文字内容 &lt;/p&gt;&lt;/div&gt; 2. 引入公共代码片段2.1 简介有两种方式引入申明过的公共代码片段： 通过th:replace引入：不保留引入公共代码片段时当前所使用的标签，即用引入的标签 替换 当前标签。 通过th:insert引入：保留引入公共代码片段时当前所使用的标签，即将公共代码块 插入 当前标签，变成当前标签的子标签。 2.2 通过th:replace引入2.2.1 引入通过th:fragment声明的公共代码片段示例： 1234&lt;!-- 通过th:replace引入通过th:fragment声明公共代码片段 注意header是文件名，header_common就是声明的属性值--&gt;&lt;div th:replace="header :: header_common"&gt;&lt;/div&gt; 2.2.2 引入通过id选择器声明的公共代码片段示例： 1234&lt;!-- 通过th:replace引入通过id选择器进行声明公共代码片段 注意header是文件名，#header_common_id就是声明的id值--&gt;&lt;div th:replace="header :: #header_common_id"&gt;&lt;/div&gt; 2.3 通过th:insert引入2.3.1 引入通过th:fragment声明的公共代码片段示例： 1&lt;h2 th:insert="header :: #header_common"&gt;&lt;/h2&gt; 2.3.2 引入通过id选择器声明的公共代码片段示例： 1&lt;h2 th:insert="header :: #header_common_id"&gt;&lt;/h2&gt;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Thymeleaf（一）]]></title>
    <url>%2F2019%2F03%2F24%2FSpring-Boot%E6%95%B4%E5%90%88Thymeleaf%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 迭代集合数据1.1 简介 使用th:each进行迭代，th:each作用在哪个标签上，就会对应的根据他的值迭代多少次。 th:each后可取两个值： use：第一个值，代表每次迭代出的对象，名字任意取。 iterStat：第二个值，代表每次迭代器的内置对象，名字任意取，并有以下属性： index：当前迭代下标从0开始。 count：当前迭代下标从1开始。 size：获取总记录数。 current：获取当前迭代的对象。 even/odd：当前迭代是否为偶数/奇数（从1开始算，返回值为布尔值）。 first：当前是否为第一个元素。 last：当前是否为最后一个元素。 1.2 迭代在当前标签的子标签上示例： 1234567&lt;tr th:each="user, iterStat : $&#123;userList&#125;"&gt; &lt;td th:text="$&#123;user.username&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.count&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.gender == 1 ? '男' : '女'&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.current&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.even ? '偶数' : '奇数'&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; 1.3 迭代在当前标签上示例： 123&lt;ul&gt; &lt;li th:each="user : $&#123;userList&#125;" th:text="$&#123;user.username&#125;"&gt;&lt;/li&gt;&lt;/ul&gt; 2. 条件判断2.1 简介 通常使用th:if和th:unless进行条件判断。 使用th:if，如果th:if为true，则显示标签的内容，否则不显示。 使用th:unless，如果th:unless为false，则显示标签内容，否则不显示。 th:if判断特殊表达式： 如果值为null，则返回false。 如果值不为null，以下情况均为true： 如果值是Boolean型且值为true。 如果值是数值型且值不为0。 如果值是字符型型且值不为空。 如果值是字符串型且值不为”false”,”off”或者”no”。 如果值不是以上的类型。那么也为true。 th:unless和th:if相反，我将”if”翻译成”如果”，将”unless”翻译成”如果不”。 2.2 th:if用法示例：假设以下代码userList不为空 1&lt;h3 th:if="not $&#123;#lists.isEmpty(userList)&#125;"&gt;显示内容&lt;/h3&gt; 结果：在网页上显示“显示内容”这四个字。 分析：${&#35;lists.isEmpty(userList)}返回值为false，则not ${&#35;lists.isEmpty(userList)}返回值为true，故显示标签内容。 2.3 th:unless用法实例：假设以下代码userList不为空 1&lt;h3 th:unless="$&#123;#lists.isEmpty(userList)&#125;"&gt;显示内容&lt;/h3&gt; 结果：在网页上显示“显示内容”这四个字。 分析：${&#35;lists.isEmpty(userList)}返回值为false，故显示标签内容。 未完待续~~]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Spring Boot配置文件简介]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%85%B3%E4%BA%8ESpring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. YAML语言1.1 简介YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，文件名以.yml结尾。 1.2 基本语法 key: value表示一对键值对（冒号后面必须要有一个空格）。 key和value大小写敏感。 使用空格缩进，不允许使用Tab键缩进，缩进表示层级关系，缩进的空格数量无要求（一般空两格），但同一层级要对齐。 使用#进行注释，从这个字符一直到行尾都会被解析器忽略。 1.3 示例1234567#emp的数据配置emp: lastName: Tom age: 22 salary: 10000 boss: true birthday: 1997/08/20 2. Spring Boot配置文件2.1 全局配置文件 可以使用.properties文件配置，命名为application.properties。 也可以使用.yml文件配置，命名为application.yml。 2.2 注解2.2.1 @ConfigurationProperties表示默认从全局配置文件application.properties或者application.yml中获取值，告诉Spring Boot将配置文件中的对应的属性值映射到这个组件类中，进行一一绑定。 全局配置文件application.yml： 123456789101112131415161718#emp的数据配置emp: lastName: Tom age: 22 salary: 10000 boss: true birthday: 1997/08/20 map: key1: value1 key2: value2 key3: value3 list: - one - two - three forte: name: java time: 8 实体类Emp.java： 123456789101112/*** * @ConfigurationProperties 加载全局配置文件，告诉SpringBoot将配置文件中的对应属性值， * 映射到这个组件类中，进行一一绑定 * prefix = "emp" 代表与配置文件中的前缀名绑定 ，配置了哪个前缀就会将配置文件的配置与下面的属性一一映射 * @Component 必须将当前组件作为SpringBoot中的一个组件来使用，这样才会纳入容器中管理 */@Component@ConfigurationProperties(prefix = "emp")public class Emp &#123; //定义成员变量、Getter和Setter方法以及toString方法的代码块&#125; 2.2.2 @Value在某个业务逻辑中需要获取配置文件中的某个属性值。 全局配置文件application.properties： 123456789101112#配置emp的数据emp.last-name=李四emp.age=30emp.salary=20000emp.birthday=1998/08/30emp.boss=falseemp.map.key1=value1emp.map.key2=value2emp.map.key3=value3emp.list=one, two, threeemp.forte.name=pythonemp.forte.time=5 控制层empController.java： 12345678910111213141516171819202122@Controllerpublic class empController &#123; /** * @Value好比Spring框架中使用配置文件的数据注入方式 * &lt;bean class="Emp"&gt; * &lt;property name="lastName" value="字面量"或者 * value=#&#123;spEL&#125;或者 * value=$&#123;key&#125;&gt;&lt;/property&gt; * &lt;/bean&gt; * #&#123;spEL&#125;即为Spring表达式，比如#&#123;3*10&#125; * $&#123;key&#125;用来引用配置文件中的数据 */ @Value("$&#123;emp.last-name&#125;") String name; @ResponseBody @RequestMapping("/say") public String sayHello() &#123; return "Hello " + name; &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
</search>
