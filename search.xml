<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[char可以储存汉字吗]]></title>
    <url>%2F2019%2F05%2F13%2Fchar%E5%8F%AF%E4%BB%A5%E5%82%A8%E5%AD%98%E6%B1%89%E5%AD%97%E5%90%97%2F</url>
    <content type="text"><![CDATA[char可以储存汉字吗？ 当然可以，Java中char型变量是用来储存Unicode编码字符的，Unicode编码字符集中包含了汉字，所以可以储存汉字。Unicode编码占用两个字节，所以char类型变量也占用两个字节。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Object类中有哪些方法]]></title>
    <url>%2F2019%2F05%2F13%2FJava-Object%E7%B1%BB%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Java Object类中有哪些方法？ hashCode、equals、clone、toString、notify、notifyAll、wait、finalize等。 Object类源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package java.lang;/** * Class &#123;@code Object&#125; is the root of the class hierarchy. * Every class has &#123;@code Object&#125; as a superclass. All objects, * including arrays, implement the methods of this class. * * @author unascribed * @see java.lang.Class * @since JDK1.0 */public class Object &#123; private static native void registerNatives(); static &#123; registerNatives(); &#125; public final native Class&lt;?&gt; getClass(); public native int hashCode(); public boolean equals(Object obj) &#123; return (this == obj); &#125; protected native Object clone() throws CloneNotSupportedException; public String toString() &#123; return getClass().getName() + "@" + Integer.toHexString(hashCode()); &#125; public final native void notify(); public final native void notifyAll(); public final native void wait(long timeout) throws InterruptedException; public final void wait(long timeout, int nanos) throws InterruptedException &#123; if (timeout &lt; 0) &#123; throw new IllegalArgumentException("timeout value is negative"); &#125; if (nanos &lt; 0 || nanos &gt; 999999) &#123; throw new IllegalArgumentException( "nanosecond timeout value out of range"); &#125; if (nanos &gt; 0) &#123; timeout++; &#125; wait(timeout); &#125; public final void wait() throws InterruptedException &#123; wait(0); &#125; protected void finalize() throws Throwable &#123; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中抽象类与接口的区别]]></title>
    <url>%2F2019%2F05%2F13%2FJava%E4%B8%AD%E6%8A%BD%E8%B1%A1%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[1. 抽象类抽象类：如果一个类中有抽象方法，那么这个类就是抽象类，抽象类必须用abstract关键字修饰。 抽象方法只声明，无具体实现。 抽象类和抽象方法必须被public或protected修饰（如果是private，则不能被子类访问到，自然无法被继承也无法被子类实现抽象方法），缺省情况下默认为public。 不能用抽象类创建对象。 如果一个子类继承一个抽象类的父类，那么子类必须实现父类的所有抽象方法，如果不全部实现，这个子类任然是抽象类，必须仍然用abstract关键字修饰。 2. 接口接口：用interface定义。 接口中所有方法都必须是抽象方法，缺省被public abstract修饰，且只能被public abstract修饰。（推荐缺省即不加修饰词，使代码简洁美观）。 接口中可以有变量，缺省被public abstract final修饰，且只能被public abstract final修饰，即变量必须给初值且不可更改。一般情况下不会在接口中定义变量。 3. 抽象类和接口的区别 抽象类在Java中表示继承关系，只能单继承，class B extends A {} 接口也能继承接口，不需要实现父接口方法，且一个接口能继承多个接口，interface C extends A, B {} 一个类可以单继承，多接口实现，class E extends D implements A, B, C {} 抽象类中可以有非抽象方法，接口中必须全部为抽象方法。 抽象类中可以有static方法（static方法是类方法，不允许子类override），接口中不能有static方法，只能是public abstract方法。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础之Iterator（迭代器）]]></title>
    <url>%2F2019%2F05%2F09%2FJava%E5%9F%BA%E7%A1%80%E4%B9%8BIterator%EF%BC%88%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. Iterator（迭代器）1.1 简介迭代器作用于集合，是用来遍历集合元素的对象。 1.2 IteratorIterator（迭代器）源自package java.util.Iterator,它是一个接口，源码如下： 12345678910111213141516public interface Iterator&lt;E&gt; &#123; boolean hasNext(); E next(); default void remove() &#123; throw new UnsupportedOperationException("remove"); &#125; default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; 其中： E next()：返回迭代的下一个元素，返回值是 Object，需要强制转换成自己需要的类型。（如果使用泛型如Iterator&lt;String&gt; iterator = list.iterator()之后返回值会从Object改为指定的引用类型） boolean hasNext()：判断是否还有元素。 default void remove()：删除新返回的元素。 1.3 IterableIterable源自package java.lang.Iterable，它也是一个接口，源码如下： 123456789101112131415public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; 该接口定义了方法Iterator&lt;T&gt; iterator()，返回值为迭代器对象，Collection接口继承了Iterable接口，而ArrayList、HashSet等实现类都实现了Collection接口，所以这些实现类的对象均可以.iterator()来创建Iterator对象。 以ArrayList为例查看继承关系： 1.4 以ArrayList为例演示Iterator的用法阿里巴巴Java开发手册强制规定了不要在 foreach 循环里进行元素的 remove/add 操作，remove 元素请使用 Iterator方式。 代码示例： 12345678910111213141516171819202122232425262728@Testpublic void testIterator() &#123; // 新建ArrayList对象并添加元素 List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("aa"); list.add("bb"); list.add("cc"); System.out.println(list); // 字符串对象，用于以下条件判断 String s = "aa"; // ArrayList对象以.iterator()来创建Iterator对象且指定了泛型为String Iterator&lt;String&gt; iterator = list.iterator(); // 判断是否还有元素 while (iterator.hasNext()) &#123; // 返回迭代的下一个元素 String item = iterator.next(); // 条件判断 if (s.equals(item)) &#123; // 移除刚返回的元素 iterator.remove(); &#125; &#125; System.out.println(list);&#125; 控制台打印信息：]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Redis]]></title>
    <url>%2F2019%2F05%2F04%2FSpring-Boot%E6%95%B4%E5%90%88Redis%2F</url>
    <content type="text"><![CDATA[1. Redis简介 在实际开发中，一般使用缓存中间件：redis、ehcache、memcache；导入了对应的组件依赖，就可以使用对应的缓存。 Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 我使用Redis作为缓存中间件。 2. 安装Redis服务和客户端2.1 Redis中文官网http://www.redis.cn/ 提供了各种对Redis的支持和参考文档以及下载，遇到问题时可以访问此网站寻求解决方法。 2.2 下载与安装 Linux版本：http://download.redis.io/releases/ Windows版本：https://github.com/MicrosoftArchive/redis/releases 我在win机上测试，下载win版，解压然后运行redis-server.exe即可。 若服务无法运行或者闪退，请参考： https://fuyuanyua.github.io/2019/04/27/redis-server-exe%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/ Redis服务启动成功： 安装 Redis 可视化客户端 redis-desktop-manager-0.8.8.384.exe。 运行redis-desktop-manager。 连接Redis服务，名字任取，Host即127.0.0.1即localhost，端口号默认6379。 连接成功。 至此Redis服务与客户端已经全部安装运行完成。 3. Redis支持的数据结构3.1 常用五种数据结构 String：&lt;key, value&gt; Hash：&lt;key，fields-values&gt; List：有顺序可重复 Set：无顺序不可重复 Sorted Sets (zset) ：有顺序，不能重复 常用五种，当然还有更多数据结构请参考： http://www.redis.cn/commands.html 3.2 String：&lt;key, value&gt; set：设置key和value。 12MyRedis:0&gt;set A hello&quot;OK&quot; get：获取指定key的value。 12MyRedis:0&gt;get A&quot;hello&quot; append：追加值。 1234MyRedis:0&gt;append A world&quot;10&quot;MyRedis:0&gt;get A&quot;helloworld&quot; incr：整数值加1。 12MyRedis:0&gt;incr A&quot;ERR value is not an integer or out of range&quot; A不是整型，所以无法执行原子加1操作。 1234567891011MyRedis:0&gt;set B 1&quot;OK&quot;MyRedis:0&gt;get B&quot;1&quot;MyRedis:0&gt;incr B&quot;2&quot;MyRedis:0&gt;get B&quot;2&quot; B是整型，执行原子加1操作。 decr：整数值减1。 12345MyRedis:0&gt;decr B&quot;1&quot;MyRedis:0&gt;get B&quot;1&quot; keys *：查看所有key。 123MyRedis:0&gt;keys * 1) &quot;B&quot; 2) &quot;A&quot; del key_name：删除指定key和他对应的value。 12MyRedis:0&gt;del B&quot;1&quot; 更多语法请参考： http://www.redis.cn/commands.html#string 3.3 Hash：&lt;key，fields-values&gt;相当于一个key对于一个Map，Map中还有key-value, 使用hash对key进行归类。 hset： 12345678MyRedis:0&gt;hset myhash a1 1&quot;1&quot;MyRedis:0&gt;hset myhash a2 2&quot;1&quot;MyRedis:0&gt;hset myhash a3 3&quot;1&quot; hget： 12MyRedis:0&gt;hget myhash a2&quot;2&quot; hgetall key_name：获取指定key的hash中所有key-value。 1234567MyRedis:0&gt;hgetall myhash 1) &quot;a1&quot; 2) &quot;1&quot; 3) &quot;a2&quot; 4) &quot;2&quot; 5) &quot;a3&quot; 6) &quot;3&quot; 更多语法请参考： http://www.redis.cn/commands.html#hash 3.4 List：有顺序可重复 lpush：向左边添加值。 12MyRedis:0&gt;lpush mylist a b c d&quot;4&quot; lrange：获取指定key的list的所有值（0表示下标从0开始，-1表示获取所有）。 12345MyRedis:0&gt;lrange mylist 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; rpush：向右边添加值。 lpop：弹出左边第一个值。 rpop：弹出右边的第一个值。 12345678910111213141516MyRedis:0&gt;rpush mylist e f g&quot;7&quot;MyRedis:0&gt;lrange mylist 0 -1 1) &quot;d&quot; 2) &quot;c&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;e&quot; 6) &quot;f&quot; 7) &quot;g&quot;MyRedis:0&gt;lpop mylist&quot;d&quot;MyRedis:0&gt;rpop mylist&quot;g&quot; 更多语法请参考： http://www.redis.cn/commands.html#list 3.5 Set：无顺序不可重复 sadd： 12MyRedis:0&gt;sadd myset a b c d e&quot;5&quot; smembers： 123456MyRedis:0&gt;smembers myset 1) &quot;c&quot; 2) &quot;d&quot; 3) &quot;b&quot; 4) &quot;a&quot; 5) &quot;e&quot; srem：移除指定元素 1234567MyRedis:0&gt;srem myset a&quot;1&quot;MyRedis:0&gt;smembers myset 1) &quot;d&quot; 2) &quot;b&quot; 3) &quot;c&quot; 4) &quot;e&quot; 更多语法请参考： http://www.redis.cn/commands.html#set 3.6 Sorted Sets (zset) ：有顺序，不能重复 zadd key score member：将所有指定成员添加到键为key有序集合（sorted set）里面。 添加时可以指定多个分数/成员（score/member）对。 如果指定添加的成员已经是有序集合里面的成员，则会更新改成员的分数（scrore）并更新到正确的排序位置，按成员得分由小到大排列。 12MyRedis:0&gt;zadd myzset 1 a 2 b 3 c&quot;3&quot; zrange： 1234567891011121314151617181920212223MyRedis:0&gt;zadd myzset 1 d 1 e&quot;2&quot;MyRedis:0&gt;zrange myzset 0 -1 1) &quot;a&quot; 2) &quot;d&quot; 3) &quot;e&quot; 4) &quot;b&quot; 5) &quot;c&quot;MyRedis:0&gt;zadd myzset 10 a&quot;0&quot;MyRedis:0&gt;zrange myzset 0 -1 withscores 1) &quot;d&quot; 2) &quot;1&quot; 3) &quot;e&quot; 4) &quot;1&quot; 5) &quot;b&quot; 6) &quot;2&quot; 7) &quot;c&quot; 8) &quot;3&quot; 9) &quot;a&quot; 10) &quot;10&quot; 更多语法请参考： http://www.redis.cn/commands.html#sorted_set]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot项目部署到云服务器]]></title>
    <url>%2F2019%2F05%2F02%2FSpring-Boot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 打包本地项目1.1 打包将本地Spring Boot项目以jar包形式打包。 IDEA最右侧栏点击Maven Projects。 找到要打包的项目，Lifecycle→package→Run Maven Build。 显示如下说明打包成功。 可在项目目录下的target目录下找到打包好的jar包。 1.2 本地测试cmd 进入jar包所在目录，运行jar包启动项目，指定80端口号，直接访问localhost或者127.0.0.1（等同于localhost）即可。 12F:\Users\Administrator\IdeaProjects\spring-boot-10-bill\target&gt;java -jar spring-boot-10-bill-0.0.1-SNAPSHOT.jar --server.port=80 2. 阿里云服务器2.1 简介阿里云官网网站：https://www.aliyun.com/ 2.2 购买先进行学生认证，然后购买仅需9.5元一个月，十分优惠。 我购买的阿里云服务器为CentOS 7.3 64位系统（什么是CentOS：https://zh.wikipedia.org/wiki/CentOS ）。 2.3 开放端口添加安全组规则，开放8080端口、80端口和3306端口。 3. 阿里云服务器安装MySQL3.1 参考安装Linux版MySQL5.7。 具体参考：https://www.jellythink.com/archives/14 4. 阿里云服务器安装JDK1.84.1 上传解压 用FileZilla（什么是FileZilla：https://themebetter.com/ftp-filezilla.html ）将 JDK安装包上传到服务器 /opt目录里面 ，右键选择上传即可。 使用secureCRT（什么是secureCRT：https://blog.csdn.net/liwf_/article/details/9429349 ）连接阿里云服务器，解压文件。 12# cd /opt # tar -zxvf JDK的文件名 ls 查看解压后的JDK。 将JDK移动到/home目录。 1# mv jdk1.8.0_171/ /home/ 4.2 配置环境变量 用vim编辑器编辑profile文件。 1# vim /etc/profile 在末尾行添加，打开后按i编辑, 按ctrl+c停止编辑，然后 :wq 保存退出。 12export JAVA_HOME=/home/jdk1.8.0_171export PATH=$PATH:$JAVA_HOME/bin: 使更改的配置立即生效。 1# source /etc/profile 查看JDK版本信息 1# java -version 此结果说明JDK安装配置成功。 5. 运行5.1 阿里云服务器MySQL建表使用MySQL Workbench访问阿里云上的数据库，建项目所需要的表。 5.2 设置MySQL开机自启动使用secureCRT设置阿里云服务器上MySQL开机自启动。 1# chkconfig mysqld on 5.3 运行项目 先用FileZilla将本地打包好的项目jar包推送到阿里云服务器。 然后用secureCRT在阿里云服务器上以后台进程并用80端口运行项目。 1# nohup java -jar 项目jar包名 --servre.port=80 &amp; 至此已经将项目在阿里云服务器全部部署完成，理论上访问阿里云服务器的IP地址，便可以成功访问本项目。 5.4 一些小问题 Linux下MySQL中文乱码（全部显示问号）， 请参考：https://blog.csdn.net/leen0304/article/details/80534609 网页响应特别慢， 请参考：https://www.cnblogs.com/zhangyuejia/p/8575080.html]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>阿里云</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的常用命令]]></title>
    <url>%2F2019%2F05%2F02%2FLinux%E7%9A%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[1. Linux的常用命令 进入指定目录，cd即change directory的缩写。 1# cd /xx/xx 进入用户主目录，即HOME变量指定的目录，如root用户的主目录为/root。 1# cd ~ 或 1# cd 返回上一级目录。 1# cd .. 查看当前目录下所有文件。 1# ls 解压压缩包到当前目录下（按Tab键可以快速补全文件名）。 1# tar -zxvf 文件名 移动指定文件或目录到指定目录下。 1# mv /xx/xx /xx/xx 用vim编辑器编辑指定文件。 1# vim /xx/xx 进入文件后： 按i：切换到输入模式，以输入字符。 按ctrl+c：暂停。 暂停后： 按:w：保存文件但不退出vim。 按:wq：保存文件并退出vim。 按:q：不保存文件，退出vim。 按:q!：不保存文件，并强制退出vim。 重新执行刚修改的初始化文件，使之立即生效。 1# source 文件名 启动以jar包形式打包的java项目。 1# java -jar 项目jar包名 以80端口启动jar包形式的java项目。 1# java -jar 项目jar包名 --servre.port=80 以后台进程运行项目。 1# nohup java -jar 项目jar包名 --servre.port=80 &amp; 查看所有java进程。 1# ps -ef|grep java 停止所有java进程。 1# pkill -9 java 停止指定java进程。 1# kill -9 java进程序号 连接本地主机mysql。 1# mysql -u 用户名 -p 密码 一般都是： 1# mysql -u root -p 随后输入密码即可进入mysql。 连接远程主机mysql。 1# mysql -h 远程主机IP地址 -u 用户名 -p 密码 未完待续…]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>命令</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-server.exe启动失败解决方案]]></title>
    <url>%2F2019%2F04%2F27%2Fredis-server-exe%E5%90%AF%E5%8A%A8%E5%A4%B1%E8%B4%A5%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[今天我下载了Win版的Redis，解压缩后，双击redis-server.exe，屏幕一闪而过，启动失败，查阅网上资料后找到解决办法。 win+R打开cmd命令。 进入F盘：f: cd到Redis包目录下：cd F:\redis\Redis-x64-3.2.100（在当前目录的地址栏直接输入cmd，可直接进入，更方便） 输入：redis-server.exe redis.windows.conf 启动成功]]></content>
      <categories>
        <category>小坑</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot缓存操作]]></title>
    <url>%2F2019%2F04%2F25%2FSpring-Boot%E7%BC%93%E5%AD%98%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 缓存1.1 简介在开发中，如果有经常频繁访问的数据，那么一般都使用缓存，以此来减少访问数据库，减轻压力。 1.2 引入缓存启动器依赖pom.xml 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 1.3 application.yml全局配置文件创建数据库bill并在user表中添加几条数据。 然后配置application.yml： 12345678910111213141516spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/bill?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver# com.example.springboot.mapper.UserMapper包下打印日志级别为debuglogging: level: com.example.springboot.mapper.UserMapper: debug# 开启自动驼峰命名方式mybatis: configuration: map-underscore-to-camel-case: true 1.4 @EnableCaching注解在启动类上使用注解@EnableCaching以开启注解版缓存。 12345678910@EnableCaching //开启注解版缓存@MapperScan("com.example.springboot.mapper")@SpringBootApplicationpublic class SpringBoot13CacheApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot13CacheApplication.class, args); &#125;&#125; 1.5 @Cacheable注解@Cacheable注解标注在方法上（一般写在Service层），该方法的返回结果就会进行缓存。 把缓存理解为一个“缓存容器”，里面有一条条key，每个key对应的value为方法返回的值。 @Cacheable的属性： cacheNames指定“缓存容器”的名字。 key指定缓存中的key值，key = &quot;#id&quot;即将方法中的参数id当做key。 Service层中代码示例： 1234567891011/** * cacheNames：缓存容器名字 * key：缓存容器中的key值，方法返回值为value值 * @param id * @return */@Cacheable(cacheNames = "user", key = "#id")public User getUserById(Integer id) &#123; User user = userMapper.getUserById(id); return user;&#125; 1.6 @CachePut注解@CachePut注解保证了修改了表中的数据后，同时更新缓存中的数据，使得别人查询这条已更新的数据直接从缓存中获取。 测试： 先查询id=1的用户，数据会放在缓存中。 后面查询id=1的用户数据都从缓存中获取。 更新id=1的用户，同时会更新缓存中的数据。 后面查询id=1的用户数据依然直接从缓存中获取。 Service层中代码示例： 1234567@CachePut(cacheNames = "user", key = "#user.id")//cacheNames = "user" 必须指定一个缓存的名称，不然报500错误//缓存都是在调用方法之后执行，而不是调用方法之前执行public User updateUser(User user) &#123; userMapper.updateUser(user); return user;&#125; 1.7 @CacheEvict注解默认情况下删除数据不会将缓存中的数据删除，使用@CacheEvict注解，使得删除数据的同时也将缓存中的数据删除。 @CacheEvict的属性： cacheNames指定“缓存容器”的名字。 key指定缓存中的key值，key = &quot;#id&quot;即将方法中的参数id当做key。 allEntries = true 会将缓存中所有数据清除，默认false。 beforeInvocation = true 在调用方法之前清理缓存，默认false（在调用方法之后再清理缓存）。 Service层中代码示例： 123456789101112/** * 默认情况下删除数据不会将缓存中的数据删除 * allEntries = true 会将缓存中所有数据清除，默认false * beforeInvocation = true 在调用方法之前清理缓存，默认false（在调用方法之后再清理缓存） * @param id * @return */@CacheEvict(cacheNames = "user", key = "#id", allEntries = true, beforeInvocation = true)public Integer deleteUserById(Integer id) &#123; userMapper.deleteUserById(id); return id;&#125; 1.8 @CacheConfig注解@CacheConfig(cacheNames = &quot;user&quot;)配置了该类下所有方法的缓存名都为”user”，这样就不用在下面每个方法的注解上指定cacheNames = &quot;user&quot;了。 代码示例： 1234567891011121314151617181920@CacheConfig(cacheNames = "user")//此注解配置了类下所有方法缓存名都为"user",就不用在下面每个方法的注解上指定cacheNames = "user"了@Servicepublic class UserService &#123; @Autowired UserMapper userMapper; /** * cacheNames：缓存容器名字 * key：缓存容器中的key值，方法返回值为value值 * @param id * @return */ @Cacheable(/*cacheNames = "user",*/ key = "#id") public User getUserById(Integer id) &#123; User user = userMapper.getUserById(id); return user; &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.04.21-23上海旅行规划]]></title>
    <url>%2F2019%2F04%2F20%2F2019-04-21-23%E4%B8%8A%E6%B5%B7%E6%97%85%E8%A1%8C%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[2019.04.21上午： 宁波（09:54）——上海虹桥（12:10） 中午： 午餐 富贵面馆 牛蛙面 安顺路175号 地铁10号线（虹桥火车站上，虹桥路下） 下午： 上海当代艺术博物馆 门票20元起 黄浦区苗江路678号 地铁4号线外圈（虹桥路上，西藏南路下） INVINCIBLE 鞋店 SOHO复兴广场，马当路388号103 地铁8号线（西藏南路上，老西门下），地铁10号线（老西门上，新天地下） CONCEPTS 鞋店 上海新天地，兴业路123弄2 步行 DOE 鞋店 黄浦区湖滨路168号 步行 晚餐 SHAKE SHACK 汉堡 上海新天地，太仓路181弄10号 步行 晚上： 南京东路 上海001，南京路步行街，外滩，上海市人民英雄纪念塔 地铁1号线（黄陂南路上，人民广场下） 回家 徐汇区复兴中路1218弄 地铁10号线（南京东路上，陕西南路下） 2019.04.22上午： 早餐 暂定 甜爱路 甜爱路，鲁迅纪念馆，多伦路文化名人街 地铁1号线（陕西南路上，人民广场下），地铁8号线（人民广场上，虹口足球场下） 中午： 午餐 蟹黄鱼 黄浦区太仓路200号一层B区 地铁8号线（虹口足球场上，人民广场下），地铁1号线（人民广场上，黄陂南路下） 下午： 武康路 武康大楼，巴金故居，法租界 地铁1号线（黄陂南路上，陕西南路下），地铁10号线（陕西南路上，交通大学下） JUICE SH 鞋店 静安区巨鹿路832号 步行或骑车 暂定 暂定 暂定 暂定 晚餐 暂定 暂定 暂定 晚上： Troye Sivan演唱会 开始时间（20:00） 上海梅赛德斯奔驰文化中心 视情况而定 暂定可选 哈灵面馆（牛蛙面） 鲜得来（排骨年糕） 红宝石（奶油小方，栗子蛋糕） 平成屋日料]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot邮件操作]]></title>
    <url>%2F2019%2F04%2F19%2FSpring-Boot%E9%82%AE%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[1. 简单邮件1.1 引入邮件依赖新建项目时在引入依赖时勾选I/O中的Mail选项，项目创建好后查看pom.xml文件有此依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 配置application.yml文件以qq邮箱为例， spring.mail.username为邮箱名，已打码。 spring.mail.password为授权第三方登录的密码。 设置发送邮件的服务器。 设置SSL连接为true。 123456789# 配置邮箱信息spring: mail: username: xxxxxxxxx@qq.com password: sroomflkeutvbbfj # 发送邮件服务器 host: smtp.qq.com # SSL连接 properties.smtp.ssl.enable: true 1.3 测试类 @Autowired JavaMailSenderImpl javaMailSender;注入JavaMailSenderImpl。 SimpleMailMessage类 封装了简单邮件。 simpleMailMessage.setFrom()发送方邮箱，已打码。 simpleMailMessage.setTo()接收方邮箱，已打码。 1234567891011121314151617181920212223@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot12MailApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; //简单邮件测试 @Test public void testSimpleMail() &#123; //SimpleMailMessage类，封装简单邮件 SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); //设置邮件主题（标题） simpleMailMessage.setSubject("标题测试"); //设置邮件正文 simpleMailMessage.setText("正文测试"); //设置发件人 simpleMailMessage.setFrom("xxxxxxxxx@qq.com"); //设置收件人 simpleMailMessage.setTo("xxxxxxxxx@gmail.com"); javaMailSender.send(simpleMailMessage); &#125;&#125; 1.4 运行接收方邮箱便能收到这份简单邮件。 2. 复杂邮件2.1 引入邮件依赖同1.1，略。 2.2 配置application.yml文件同1.2，略。 2.3 测试类 MimeMessage类的对象不能直接设置标题正文等发送内容。 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true);需要通过MimeMessageHelper类的对象来设置发送内容。 mimeMessageHelper.setText()第二个参数设置为true，才能使用html代码。 mimeMessageHelper.addAttachment()设置附件，第一个参数指定附件名。 1234567891011121314151617181920212223242526@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringBoot12MailApplicationTests &#123; @Autowired JavaMailSenderImpl javaMailSender; //复杂邮件测试 @Test public void testMimeMail() throws MessagingException &#123; //MimeMessage类 MimeMessage mimeMessage = javaMailSender.createMimeMessage(); //通过MimeMessage帮助对象 来设置发送内容，第二个参数为true表示可以发送附件 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); //设置邮件主题（标题） mimeMessageHelper.setSubject("标题测试1"); //设置邮件正文,第二个参数设置为true，才可以发送html代码 mimeMessageHelper.setText("&lt;h2 style='color:red'&gt;正文测试2&lt;/h2&gt;", true); mimeMessageHelper.addAttachment("1.jpg", new File("D:\\用户目录\\我的图片\\02_CONVERSEXMDNS_LANDINGPAGE_20181007_01.jpg")); //设置发件人 mimeMessageHelper.setFrom("xxxxxxxxx@qq.com"); //设置收件人 mimeMessageHelper.setTo("xxxxxxxxx@gmail.com"); javaMailSender.send(mimeMessage); &#125;&#125; 2.4 运行接收方邮箱便能收到邮件，且邮件带有一份名为1.jpg的附件。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>邮件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot异步任务和定时任务]]></title>
    <url>%2F2019%2F04%2F17%2FSpring-Boot%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[1. 异步任务1.1 简介项目开发中，绝大多数情况是通过同步方式处理业务逻辑，但批量处理数据，批量发送邮件等容易造成阻塞，之前都是通过使用多线程来完成此类任务。 在Spring 3+后内置了@Async注解来解决此类问题，提高效率。 1.2 启动类上使用@EnableAsync注解在启动类上使用@EnableAsync注解，开启基于注解版的异步处理。 代码示例： 123456789@EnableAsync //开启基于注解版的异步处理@SpringBootApplicationpublic class SpringBoot11TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot11TaskApplication.class, args); &#125;&#125; 1.3 在方法上使用@Async注解在方法上标识@Async注解，该方法就会基于异步处理。 代码示例： 1234567891011121314@Servicepublic class AsyncService &#123; @Async //在该方法上标识注解，该方法就会基于异步处理 public void batchAdd() &#123; try &#123; //模拟新增数据 Thread.sleep(3*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("批量新增数据完成"); &#125;&#125; 2. 定时任务2.1 简介在项目开发中，经常要执行一些定时任务。 2.2 启动类上使用@EnableScheduling注解在启动类上使用@EnableScheduling注解，开启注解版的定时任务。 代码示例： 123456789@EnableScheduling //开启注解版的定时任务@SpringBootApplicationpublic class SpringBoot11TaskApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot11TaskApplication.class, args); &#125;&#125; 2.3 在方法上使用@Scheduled注解代码示例： 123456789101112131415@Servicepublic class ScheduledService &#123; private static int count = 1; /** * on the second(秒) as well as minute(分), hour(时), day(天) of month, month(月) and day of week(星期). * &lt;p&gt;E.g. &#123;@code "0 * * * * MON-FRI"&#125; means once per minute on weekdays 表示在工作日（周一到周五）每分钟执行一次 */ //cron = "*/3 * * * * MON-FRI"表示在周一到周五每三秒执行一次 @Scheduled(cron = "*/3 * * * * MON-FRI") public void dataCount() &#123; System.out.println("数据统计第" + count++ + "次"); &#125;&#125; 2.3 @Scheduled详解 @Scheduled(cron = &quot;*/3 * * * * MON-FRI&quot;)：通过cron表达式定义规则。 cron表达式自动生成网站： http://cron.qqe2.com/ 从左到右依次 取值范围 可指定的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 小时 0-23 , - * / 日期 1-31 , - * / ? L W C 月份 1-12 , - * / 星期 0-7或MON-SUN（0和7都代表周日，1-6代表周一到周六） , - * / ? L C # @Scheduled(fixedRate = 3000):上一次开始执行时间点之后3秒再执行。 @Scheduled(fixedDelay = 3000)：上一次执行完毕时间点之后3秒再执行。 @Scheduled(initialDelay=1000, fixedRate=3000)：第一次延迟1秒后执行，之后按fixedRate的规则每3秒执行一次。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>异步任务</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合MyBatis]]></title>
    <url>%2F2019%2F04%2F10%2FSpring-Boot%E6%95%B4%E5%90%88MyBatis%2F</url>
    <content type="text"><![CDATA[1. Spring Boot整合MyBatis配置文件版1.1 建表使用MySQL数据库，新建一个名为“mybatis”的schema，分别建“bill“、”provider“和”user“表并添加数据。 1.2 application.yml全局配置文件12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 1.3 创建实体类在 com.example.springboot.entities 包下创建Provider实体类和Bill实体类。 Provider类： 为减少篇幅，这里只给出成员变量，有参、无参构造方法，get，set，toString方法均省略。 123456789101112131415161718192021public class Provider &#123; private Integer pid; //供应商编码 private String providerCode; //供应商名称 private String providerName; //联系人 private String people; //联系电话 private String phone; //联系地址 private String address; //传真 private String fax; //描述 private String describe; // 创建时间 private Date createDate; 其余代码省略。。。&#125; Bill类： 为减少篇幅，这里只给出成员变量，有参、无参构造方法，get，set，toString方法均省略。 12345678910111213141516171819202122public class Bill &#123; private Integer bid; // 账单编码 private String billCode; // 商品名称 private String billName; // 商品单位 private String billCom; // 商品数量 private Integer billNum; // 总金额 private Double money; // 供应商 private Provider provider; // 是否付款 0 未付款， 1已付款 private Integer pay; // 创建时间 private Date createDate; 其余代码省略。。。&#125; 1.4 创建Mapper接口在 com.example.springboot.mapper 包下创建 BillMapper 接口： 可在各Mapper接口上使用@Mapper注解，表明这是一个Mapper接口。 也可在启动类上直接使用注解@MapperScan(&quot;com.example.springboot.mapper&quot;)，便能扫描该包下的所有Mapper自动装到容器当中，而不用在各Mapper上加上注解@Mapper。 代码示例： BillMapper接口： 12345678910111213141516/** * 使用MyBatis配置文件版 *///@Mapper 或者在启动类上使用注解 @MapperScan("com.example.springboot.mapper")public interface BillMapper &#123; //接口方法默认被public修饰 Bill getBillByBid(Integer bid); int addBill(Bill bill); int updateBill(Bill bill); int deleteBill(Integer bid);&#125; 启动类： 12345678910@MapperScan("com.example.springboot.mapper")//扫描该包下的所有Mapper自动装到容器当中，而不用在各Mapper上加上注解@Mapper@SpringBootApplicationpublic class SpringBoot08DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataMybatisApplication.class, args); &#125;&#125; 1.5 创建MyBatis核心配置文件在resources目录下新建mybatis目录，在该目录下创建mybatis-config.xml，这便是MyBatis核心配置文件，我在这仅仅配置了开启自动驼峰命名规则映射，文件编写参考官方文档：http://www.mybatis.org/mybatis-3/zh/getting-started.html 代码示例： 123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!-- 这是mybatis核心配置文件 --&gt; &lt;settings&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射， 即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt; &lt;/settings&gt;&lt;/configuration&gt; 1.6 创建Mapper映射配置文件在resources目录的mybatis目录下新建mapper目录，在该目录下创建BillMapper.xml，在此文件中编写sql语句，文件编写也参考官网文档：http://www.mybatis.org/mybatis-3/zh/getting-started.html 代码示例： 123456789101112131415&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.example.springboot.mapper.BillMapper"&gt; &lt;select id="getBillByBid" resultType="com.example.springboot.entities.Bill"&gt; select * from bill where bid = #&#123;bid&#125; &lt;/select&gt; &lt;insert id="addBill"&gt; insert into bill(bill_code, bill_name, bill_com, bill_num) values (#&#123;billCode&#125;, #&#123;billName&#125;, #&#123;billCom&#125;, #&#123;billNum&#125;) &lt;/insert&gt;&lt;/mapper&gt; &lt;mapper namespace=&quot;com.example.springboot.mapper.BillMapper&quot;&gt;定义了对应接口BillMapper的路径。 以查询为例，select id=&quot;getBillByBid&quot;，getBillByBid与接口中的方法Bill getBillByBid(Integer bid);对应，resultType=&quot;com.example.springboot.entities.Bill&quot;则是方法返回值的实体类Bill的路径。 #{}用于表示一个占位符，相当于?，而#{bid}则表示该占位符待接收参数的名称为bid。 1.7 重新配置application.yml全局配置文件1234567891011121314151617181920212223242526272829303132333435spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500# mybatis配置文件版，配置相关文件路径mybatis: # 映射文件路径 mapper-locations: classpath:mybatis/mapper/*.xml # mybatis核心配置文件路径 config-location: classpath:mybatis/mybatis-config.xml classpath:表示类路径，在Spring Boot项目里等同于resources目录，在其他项目也可等同于res目录。 *.xml表示该目录下所有.xml文件。 1.8 创建控制层在com.example.springboot.controller包下新建类BillController： 123456789101112131415161718@RestControllerpublic class BillController &#123; @Autowired BillMapper billMapper; @GetMapping("/bill/&#123;bid&#125;") public Bill getBillByBid(@PathVariable("bid") Integer bid) &#123; Bill bill = billMapper.getBillByBid(bid); return bill; &#125; @GetMapping("/bill") public Bill addBill(Bill bill) &#123; int i = billMapper.addBill(bill); return bill; &#125;&#125; @RestController注解等同于@Controller+@ResponseBody这两个注解合在一起的作用，表示不返回jsp或html页面，直接返回return的内容。 @Autowired BillMapper billMapper; 表示直接将BillMapper接口注入。 1.9 测试启动启动类SpringBoot08DataMybatisApplication，在浏览器输入：http://localhost:8080/bill/1 效果显示： 数据库中bill表： 网页中数据与数据库中均一一对应，表明成功。 2. Spring Boot整合MyBatis注解版2.1 建表同1.1，表已经建好。 2.2 application.yml全局配置文件12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/mybatis?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 2.3 创建实体类同1.3，实体类均已创建好。 2.4 创建Mapper接口在 com.example.springboot.mapper 包下创建 ProviderMapper 接口。 代码示例： ProviderMapper接口： 123456789101112131415161718192021222324/** * 使用mybatis注解版 */@Mapper //这是指定操作数据的Mapperpublic interface ProviderMapper &#123; //接口默认public修饰 //查 @Select("select * from provider where pid = #&#123;pid&#125;") Provider getProviderByPid(Integer pid); //增 @Insert("insert into provider(providerName) values (#&#123;providerName&#125;)") int addProvider(Provider provider); //删 @Delete("delete from provider where pid = #&#123;pid&#125;") int deleteProviderByPid(Integer pid); //改 @Update("update provider set providerName = #&#123;providerName&#125;") int updateProvider(Provider provider);&#125; 启动类： 12345678@SpringBootApplicationpublic class SpringBoot08DataMybatisApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataMybatisApplication.class, args); &#125;&#125; 2.5 创建控制层在 com.example.springboot.controller 包下创建ProviderController类。 代码示例： 123456789101112@RestControllerpublic class ProviderController &#123; @Autowired ProviderMapper providerMapper; @GetMapping("/provider/&#123;pid&#125;") public Provider getProvider(@PathVariable("pid") Integer pid) &#123; Provider provider = providerMapper.getProviderByPid(pid); return provider; &#125;&#125; 2.6 创建MyBatis配置类因为MyBatis注解版没有xml配置文件，所以需要使用配置类来配置，我在 com.example.springboot.config 包下创建MyBatisConfig类，主要配置了开启了自动驼峰命名规则映射。 代码示例： 12345678910111213141516@Configurationpublic class MyBatisConfig &#123; @Bean public ConfigurationCustomizer ConfigurationCustomizer() &#123; ConfigurationCustomizer configurationCustomizer = new ConfigurationCustomizer() &#123; @Override public void customize(org.apache.ibatis.session.Configuration configuration) &#123; //是否开启自动驼峰命名规则（camel case）映射， // 即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 configuration.setMapUnderscoreToCamelCase(true); &#125; &#125;; return configurationCustomizer; &#125;&#125; 2.7 测试启动启动类SpringBoot08DataMybatisApplication，在浏览器输入：http://localhost:8080/provider/1 网页效果： 数据表： 测试成功。 3. 心得无论Mybatis注解版还是配置文件版，都能实现相同功能，所以都需要掌握。 但是本人更倾向于配置文件版，因为如果遇到复杂的sql语句，写在注解上让代码显得特别繁琐复杂，而单独写在mapper映射文件中则显得简洁许多。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>MyBatis</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot事务管理]]></title>
    <url>%2F2019%2F04%2F09%2FSpring-Boot%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1. 事务管理1.1 简介事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。事务的结束有两种，当事务中的所以步骤全部成功执行时，事务提交。如果其中一个步骤失败，将发生回滚操作，撤消撤消之前到事务开始时的所以操作。在Spring Boot中，使用了spring-boot-starter-jdbc或者spring-boot-starter-data-jpa依赖时，框架会自动默认注入DataSourceTransactionManager或者jpaTransactionManager。所以我们不需要任何额外配置就可以用@Transactional注解进行事务的使用。 1.2 事务管理步骤 在启动类中，使用@EnableTransactionManagement开启注解方式事务管理支持。 123456789@EnableTransactionManagement //开启注解方式事务支持@SpringBootApplicationpublic class SpringBoot08DataJpaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBoot08DataJpaApplication.class, args); &#125;&#125; 在Service层方法上使用@Transactional注解。 @Transactional也可直接注解在类上，这样默认该类下所有方法都开启事务注解。 但实际中一般只对 增、删、改 进行事务管理，不对 查 进行事务管理，所以注解在方法上。 1.3 注意 application.yml配置文件 1234567891011121314spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/jpa?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关配置 jpa: hibernate: # 会根据映射实体类自动创建会更新数据表 ddl-auto: update # 控制台打印sql语句 show-sql: true 如果使用 JPA（Java Persistence API），hibernate在自动创建表时，创建的表引擎是 MyISAM，是非事务安全的，无法实现事务回滚。需要指定 InnoDB 引擎才可以进行事务管理。 在application.yml配置文件中添加配置 12345678910111213141516spring: datasource: username: root password: root url: jdbc:mysql://localhost:3306/jpa?serverTimezone=GMT%2B8 driver-class-name: com.mysql.cj.jdbc.Driver # jpa相关配置 jpa: hibernate: # 会根据映射实体类自动创建会更新数据表 ddl-auto: update # 控制台打印sql语句 show-sql: true # 指定表的引擎为InnoDB，如果不指定，则默认表引擎为MyISAM,MyISAM是不支持事务管理的 database-platform: org.hibernate.dialect.MySQL57Dialect 2. 事务的隔离级别2.1 脏读、不可重复读和幻读 脏读：A事务执行过程中修改了id=1的数据，未提交前，B事务读取了A事务修改的id=1的数据，而这时A事务却回滚了，这样B事务就形成了脏读。 不可重复读：A事务先读取了一条数据，然后执行逻辑，这时B事务将这条数据改变了，然后A事务再次读取这条数据，发现数据不匹配了，这就是不可重复读。 幻读：A事务先根据条件查询到了N调数据，然后这时B事务新增了M条符合A事务查询条件的数据，A事务再次查询时发现有N+M条数据了，就产生了幻读。 2.2 隔离级别数据库事务的隔离级别有4个，由低到高依次为Read uncommitted 、Read committed 、Repeatable read 、Serializable ，这四个级别可以逐个解决脏读 、不可重复读 、幻读这几类问题。 隔离级别 脏读 不可重复读 幻读 Read uncommitted（读未提交） √ √ √ Read committed（读提交） × √ √ Repeatable read（重复读） × × √ Serializable（序列化） × × × 2.3 源码查看org.springframework.transaction.annotation包中的枚举类Isolation定义了五个表示隔离级别的值： 12345678910111213141516171819package org.springframework.transaction.annotation;public enum Isolation &#123; DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8); private final int value; private Isolation(int value) &#123; this.value = value; &#125; public int value() &#123; return this.value; &#125;&#125; DEFAULT：默认值，表示使用底层数据库的默认隔离级别，大多数数据库的默认隔离级别是READ_COMMITTED。 READ_UNCOMMITTED：通常很少使用该隔离级别，因为避免不了脏读、不可重复读和幻读。 READ_COMMITTED：可以防止脏读，也是大多数数据库的默认隔离级别，比如SQL Server , Oracle，性能最好。 REPEATABLE_READ：可以避免脏读和不可重复读，是MySQL的默认隔离级别。 SERIALIZABLE：可以避免脏读、不可重复读和幻读，但严重影响程序性能，通常不会用到该级别。 2.4 指定隔离级别在@Transactional注解上设置属性： 123@Transactional(isolation = Isolation.DEFAULT) //当前方法开启事务管理 //isolation指定隔离级别，当前指定为默认 3. 事务的传播行为3.1 源码查看org.springframework.transaction.annotation包中的枚举类Propagation定义了七个表示传播行为的值： 123456789101112131415161718192021package org.springframework.transaction.annotation;public enum Propagation &#123; REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6); private final int value; private Propagation(int value) &#123; this.value = value; &#125; public int value() &#123; return this.value; &#125;&#125; REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。如果A方法有事务，那么B方法就使用A方法的事务。如果A方法没有事务，那么B方法就创建一个新事物。是Spring提供的默认事务传播行为，适合绝大数情况。 SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。如果A方法有事务，那么B方法就使用A方法的事务。如果A方法没有事务，那么B方法就不使用事务的方式执行 MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。如果A方法有事务，那么A方法就使用A方法事务。如果A方法没有事务，那么就抛出异常。该事务传播行为要求A方法必须以事务的方式运行。 REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。如果A方法有事务，就把A方法的事务挂起，B方法新创建一个事务。如果A方法没有事务，那么B方法就创建一个新事务。 NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。如果A方法有事务，那么就把A方法的事务挂起，B方法以非事务的方式执行。如果A方法没有事务，那么B也不使用事务执行。 NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。如果方法A有事务，那么就抛出异常。如果方法A没有事务，那么B方法就以非事务的方式运行。 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的。如果A方法有事务，那么B方法就在A方法的事务中使用嵌套事务。如果A方法没有事务，那么方法B就新创建一个事务。 3.2 指定传播行为在@Transactional注解上设置属性： 1234@Transactional(isolation = Isolation.DEFAULT, propagation = Propagation.REQUIRED )//当前方法开启事务管理//isolation指定隔离级别，当前指定为默认//propagation指定传播行为，当前指定为默认]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>事务管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[配置Druid数据库连接池]]></title>
    <url>%2F2019%2F04%2F04%2F%E9%85%8D%E7%BD%AEDruid%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[1. 配置Druid数据库连接池什么是数据库连接池？ 参考：https://www.cnblogs.com/aspirant/p/6747238.html Spring Boot 2.0 默认使用 HikariCP 作为数据库连接池。 Druid 是阿里巴巴推出的国产数据库连接池，据网上测试对比，比目前的 DBCP 或 C3P0 数据库连接池性能更好，并且 Druid 能够提供强大的监控和扩展功能。 1.1 在pom.xml中引入依赖123456&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt; 1.2 在全局配置文件application.yml中配置12345678910111213141516171819202122232425262728spring: datasource: username: root password: root # mysql-connector-java 8.0版本以上的驱动包要指定时区 url: jdbc:mysql://localhost:3306/jdbc?serverTimezone=GMT%2B8 # mysql-connector-java 8.0版本以上指定了新的驱动类 driver-class-name: com.mysql.cj.jdbc.Driver # 使用阿里的Druid（德鲁伊）数据源 type: com.alibaba.druid.pool.DruidDataSource # 数据源其他配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,logback maxPoolPreparedStatementPerConnectionSize: 20 useGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 1.3 绑定Druid相关信息在config目录下新建类DruidConfig 123456789@Configurationpublic class DruidConfig &#123; @ConfigurationProperties(prefix = "spring.datasource") @Bean public DataSource druid() &#123; return new DruidDataSource(); &#125;&#125; 至此Druid数据库连接池配置完毕。 2. 配置Druid的监控Druid 自带监控管理系统，要配置一个Druid监控： 配置一个Druid的Servlet 配置一个Druid的Filter 完成 2.1 配置一个Druid的Servlet在config目录下DruidConfig类下: 1234567891011121314151617//配置一个Druid的后台管理系统的Servlet@Beanpublic ServletRegistrationBean statViewServlet() &#123; //请求是/druid/* ServletRegistrationBean&lt;StatViewServlet&gt; bean = new ServletRegistrationBean&lt;&gt;(new StatViewServlet(), "/druid/*"); //设置初始化参数值 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(StatViewServlet.PARAM_NAME_USERNAME, "root"); map.put(StatViewServlet.PARAM_NAME_PASSWORD, "123456"); //如果不写，则默认所有IP地址都可以访问 map.put(StatViewServlet.PARAM_NAME_ALLOW, ""); //指定IP地址禁止访问 map.put(StatViewServlet.PARAM_NAME_DENY, "192.168.1.1"); bean.setInitParameters(map); return bean;&#125; 2.2 配置一个Druid的Filter在config目录下DruidConfig类下: 123456789101112131415//配置一个Druid的Filter@Beanpublic FilterRegistrationBean webStatFilter() &#123; FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;(); bean.setFilter(new WebStatFilter()); //设置不拦截的请求 Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put(WebStatFilter.PARAM_NAME_EXCLUSIONS, "*.js, *.css, /druid/*"); bean.setInitParameters(map); //设置拦截请求, /* 表示拦截所有请求 bean.setUrlPatterns(Arrays.asList("/*")); return bean;&#125;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot嵌入式Servlet容器]]></title>
    <url>%2F2019%2F04%2F03%2FSpring-Boot%E5%B5%8C%E5%85%A5%E5%BC%8FServlet%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[1. 修改Servlet配置参考pom.xml文件可以知道，Spring Boot默认使用Tomcat作为嵌入式的Servlet容器。 1.1 通过全局配置文件修改Servlet配置通过修改全局配置文件application.properties，修改嵌入式Servlet容器配置： 12345678910# 修改关于服务的相关配置，对应的类是ServerProperties# 修改端口号server.port=8081# 修改Servlet的相关配置，修改应用名server.servlet.context-path=/servlet# 修改Tomcat的相关配置server.tomcat.max-connections=80000 1.2 通过自定义配置器修改Servlet配置Spring Boot 2.x： 实现WebServerFactoryCustomizer接口的customize抽象方法： 123456789101112131415161718/** * 自定义定制器修改Servlet容器配置 */@Beanpublic WebServerFactoryCustomizer webServerFactoryCustomizer() &#123; //采用匿名内部类实现WebServerFactoryCustomizer接口的void customize(T factory)抽象方法 return new WebServerFactoryCustomizer() &#123; @Override public void customize(WebServerFactory factory) &#123; ConfigurableServletWebServerFactory factory1 = (ConfigurableServletWebServerFactory) factory; //修改端口号，如果全局配置文件中的配置与定制器的配置冲突，默认采用定制器的配置 factory1.setPort(8082); //修改应用名 factory1.setContextPath("/servlet2"); &#125; &#125;;&#125; 2. 切换为其他嵌入式Servlet容器Spring Boot默认针对Servlet容器提供以下支持： Tomcat（默认使用）。 Jetty：支持长连接项目（如：聊天页面）。 Undertow：不支持jsp，但是并发性能高，是高性能非阻塞的容器。 2.1 使用Jetty 在pom.xml文件中移除Tomcat 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;!-- 移除Tomcat启动器 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 引入Jetty依赖 12345&lt;!-- 引入Jetty启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt; 2.2 使用Undertow 在pom,xml文件中移除Tomcat，代码同上。 引入Undertow依赖 12345&lt;!-- 引入Undertow启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中pom文件的依赖配置]]></title>
    <url>%2F2019%2F04%2F02%2FSpring-Boot%E4%B8%ADpom%E6%96%87%E4%BB%B6%E7%9A%84%E4%BE%9D%E8%B5%96%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[1. pom.xml文件中依赖配置Spring Boot中需要使用什么，只需在pom.xml文件中引入相对应的依赖即可，以下来介绍各种依赖。 1.1 thymeleaf模板启动器12345&lt;!-- 引入thymeleaf模板启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 1.2 注释处理器123456&lt;!-- 该依赖为注释处理器，在编写配置文件时能自动提示自定义的类 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 1.3 热部署12345&lt;!-- 热部署依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 1.4 jquery webjars123456&lt;!-- 引入jquery webjars --&gt;&lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.3.1-2&lt;/version&gt;&lt;/dependency&gt; 1.5 Druid数据库连接池1234567&lt;!-- Druid数据库连接池 --&gt;&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.15&lt;/version&gt;&lt;/dependency&gt; 1.6 MyBatis123456&lt;!-- MyBatis启动器，已经引入了spring-boot-starter-jdbc启动器 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 1.7 JDBC1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;&lt;/dependency&gt; 1.8 Java连接MySQL驱动包123456&lt;!-- Java连接MySQL驱动包 --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt;&lt;/dependency&gt;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot实现热部署]]></title>
    <url>%2F2019%2F04%2F02%2FSpring-Boot%E5%AE%9E%E7%8E%B0%E7%83%AD%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[1. Spring Boot实现项目的热部署1.1 简介Spring Boot项目的热部署，按照我的理解，就是在修改代码后，无须重新启动服务器，只需要重新Build Project，然后刷新网页，就可以立即在网页查看到修改后的变化。 1.2 在配置文件中禁用模板缓存如果不禁用缓存，那么因为有网页的缓存，变化无法实时获取，所以在配置文件application.properties或者application,yml中禁用Thymeleaf模板缓存，下面以application.properties配置文件为例： 12# 开发中推荐关闭thymeleaf的缓存，可以实现热部署spring.thymeleaf.cache=false 1.3 在pom.xml文件中引入依赖在pom.xml文件中引入热部署依赖： 12345&lt;!-- 热部署依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt; 1.4 实现按IDEA快捷键 ctrl+F9 进行Build Project，无须重新启动服务器，然后刷新网页即可实现项目的热部署。]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Thymeleaf（二）]]></title>
    <url>%2F2019%2F03%2F31%2FSpring-Boot%E6%95%B4%E5%90%88Thymeleaf%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 声明公共代码片段1.1 简介有两种方式声明公共代码片段： 通过th:fragment声明公共代码片段。 通过id选择器声明公共代码片段。 1.2 通过th:fragment声明示例： 123456&lt;!-- 通过th:fragment声明公共代码片段 --&gt;&lt;div th:fragment="header_common"&gt; &lt;p&gt; 文字内容 &lt;/p&gt;&lt;/div&gt; 1.3 通过id选择器声明示例： 123456&lt;!-- 通过id选择器进行声明公共代码片段 --&gt;&lt;div id="header_common_id"&gt; &lt;p&gt; 文字内容 &lt;/p&gt;&lt;/div&gt; 2. 引入公共代码片段2.1 简介有两种方式引入申明过的公共代码片段： 通过th:replace引入：不保留引入公共代码片段时当前所使用的标签，即用引入的标签 替换 当前标签。 通过th:insert引入：保留引入公共代码片段时当前所使用的标签，即将公共代码块 插入 当前标签，变成当前标签的子标签。 2.2 通过th:replace引入2.2.1 引入通过th:fragment声明的公共代码片段示例： 1234&lt;!-- 通过th:replace引入通过th:fragment声明公共代码片段 注意header是文件名，header_common就是声明的属性值--&gt;&lt;div th:replace="header :: header_common"&gt;&lt;/div&gt; 2.2.2 引入通过id选择器声明的公共代码片段示例： 1234&lt;!-- 通过th:replace引入通过id选择器进行声明公共代码片段 注意header是文件名，#header_common_id就是声明的id值--&gt;&lt;div th:replace="header :: #header_common_id"&gt;&lt;/div&gt; 2.3 通过th:insert引入2.3.1 引入通过th:fragment声明的公共代码片段示例： 1&lt;h2 th:insert="header :: #header_common"&gt;&lt;/h2&gt; 2.3.2 引入通过id选择器声明的公共代码片段示例： 1&lt;h2 th:insert="header :: #header_common_id"&gt;&lt;/h2&gt;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot整合Thymeleaf（一）]]></title>
    <url>%2F2019%2F03%2F24%2FSpring-Boot%E6%95%B4%E5%90%88Thymeleaf%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1. 迭代集合数据1.1 简介 使用th:each进行迭代，th:each作用在哪个标签上，就会对应的根据他的值迭代多少次。 th:each后可取两个值： use：第一个值，代表每次迭代出的对象，名字任意取。 iterStat：第二个值，代表每次迭代器的内置对象，名字任意取，并有以下属性： index：当前迭代下标从0开始。 count：当前迭代下标从1开始。 size：获取总记录数。 current：获取当前迭代的对象。 even/odd：当前迭代是否为偶数/奇数（从1开始算，返回值为布尔值）。 first：当前是否为第一个元素。 last：当前是否为最后一个元素。 1.2 迭代在当前标签的子标签上示例： 1234567&lt;tr th:each="user, iterStat : $&#123;userList&#125;"&gt; &lt;td th:text="$&#123;user.username&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.count&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;user.gender == 1 ? '男' : '女'&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.current&#125;"&gt;&lt;/td&gt; &lt;td th:text="$&#123;iterStat.even ? '偶数' : '奇数'&#125;"&gt;&lt;/td&gt;&lt;/tr&gt; 1.3 迭代在当前标签上示例： 123&lt;ul&gt; &lt;li th:each="user : $&#123;userList&#125;" th:text="$&#123;user.username&#125;"&gt;&lt;/li&gt;&lt;/ul&gt; 2. 条件判断2.1 简介 通常使用th:if和th:unless进行条件判断。 使用th:if，如果th:if为true，则显示标签的内容，否则不显示。 使用th:unless，如果th:unless为false，则显示标签内容，否则不显示。 th:if判断特殊表达式： 如果值为null，则返回false。 如果值不为null，以下情况均为true： 如果值是Boolean型且值为true。 如果值是数值型且值不为0。 如果值是字符型型且值不为空。 如果值是字符串型且值不为”false”,”off”或者”no”。 如果值不是以上的类型。那么也为true。 th:unless和th:if相反，我将”if”翻译成”如果”，将”unless”翻译成”如果不”。 2.2 th:if用法示例：假设以下代码userList不为空 1&lt;h3 th:if="not $&#123;#lists.isEmpty(userList)&#125;"&gt;显示内容&lt;/h3&gt; 结果：在网页上显示“显示内容”这四个字。 分析：${&#35;lists.isEmpty(userList)}返回值为false，则not ${&#35;lists.isEmpty(userList)}返回值为true，故显示标签内容。 2.3 th:unless用法实例：假设以下代码userList不为空 1&lt;h3 th:unless="$&#123;#lists.isEmpty(userList)&#125;"&gt;显示内容&lt;/h3&gt; 结果：在网页上显示“显示内容”这四个字。 分析：${&#35;lists.isEmpty(userList)}返回值为false，故显示标签内容。 未完待续~~]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>Thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Spring Boot配置文件简介]]></title>
    <url>%2F2019%2F03%2F22%2F%E5%85%B3%E4%BA%8ESpring-Boot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[1. YAML语言1.1 简介YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，文件名以.yml结尾。 1.2 基本语法 key: value表示一对键值对（冒号后面必须要有一个空格）。 key和value大小写敏感。 使用空格缩进，不允许使用Tab键缩进，缩进表示层级关系，缩进的空格数量无要求（一般空两格），但同一层级要对齐。 使用#进行注释，从这个字符一直到行尾都会被解析器忽略。 1.3 示例1234567#emp的数据配置emp: lastName: Tom age: 22 salary: 10000 boss: true birthday: 1997/08/20 2. Spring Boot配置文件2.1 全局配置文件 可以使用.properties文件配置，命名为application.properties。 也可以使用.yml文件配置，命名为application.yml。 2.2 注解2.2.1 @ConfigurationProperties表示默认从全局配置文件application.properties或者application.yml中获取值，告诉Spring Boot将配置文件中的对应的属性值映射到这个组件类中，进行一一绑定。 全局配置文件application.yml： 123456789101112131415161718#emp的数据配置emp: lastName: Tom age: 22 salary: 10000 boss: true birthday: 1997/08/20 map: key1: value1 key2: value2 key3: value3 list: - one - two - three forte: name: java time: 8 实体类Emp.java： 123456789101112/*** * @ConfigurationProperties 加载全局配置文件，告诉SpringBoot将配置文件中的对应属性值， * 映射到这个组件类中，进行一一绑定 * prefix = "emp" 代表与配置文件中的前缀名绑定 ，配置了哪个前缀就会将配置文件的配置与下面的属性一一映射 * @Component 必须将当前组件作为SpringBoot中的一个组件来使用，这样才会纳入容器中管理 */@Component@ConfigurationProperties(prefix = "emp")public class Emp &#123; //定义成员变量、Getter和Setter方法以及toString方法的代码块&#125; 2.2.2 @Value在某个业务逻辑中需要获取配置文件中的某个属性值。 全局配置文件application.properties： 123456789101112#配置emp的数据emp.last-name=李四emp.age=30emp.salary=20000emp.birthday=1998/08/30emp.boss=falseemp.map.key1=value1emp.map.key2=value2emp.map.key3=value3emp.list=one, two, threeemp.forte.name=pythonemp.forte.time=5 控制层empController.java： 12345678910111213141516171819202122@Controllerpublic class empController &#123; /** * @Value好比Spring框架中使用配置文件的数据注入方式 * &lt;bean class="Emp"&gt; * &lt;property name="lastName" value="字面量"或者 * value=#&#123;spEL&#125;或者 * value=$&#123;key&#125;&gt;&lt;/property&gt; * &lt;/bean&gt; * #&#123;spEL&#125;即为Spring表达式，比如#&#123;3*10&#125; * $&#123;key&#125;用来引用配置文件中的数据 */ @Value("$&#123;emp.last-name&#125;") String name; @ResponseBody @RequestMapping("/say") public String sayHello() &#123; return "Hello " + name; &#125;&#125;]]></content>
      <categories>
        <category>Spring Boot笔记</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
</search>
